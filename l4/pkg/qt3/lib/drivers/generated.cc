/* Generated from de.xml on Thu Dec 09 14:39:26 CET 2004 */
/* Generator: keymapxml2cpp (http://www.inf.tu-dresden.de/~js177634/drops/keymap/) */
/* DO NOT EDIT THIS FILE! */

/* Definition of all possible key modifiers (composite key sequences) */
#define Shift 1
#define Caret_Shift 2
#define Accent_backward 3
#define Accent_backward_Shift 4
#define Accent_Shift 5
#define Alt_Right 6
#define Tilde 7
#define Tilde_Shift 8
#define Caret 9
#define Alt_Right_Shift 10
#define Accent 11

#ifndef NULL
#define NULL (char*)0
#endif

/* Keycode conversion type */
typedef struct composite
{
	int keycode;
	int mod;
	char *modcode;
};

/* Composite key type */
typedef struct modifier
{
	int oldmod;
	int keycode;
	int mod;
};

/* Keycode conversion table */
const struct composite compositemap[] =
{
	{1, 0, NULL}, /* Escape */
	{42, 0, NULL}, /* Shift */
	{54, 0, NULL}, /* Shift */
	{58, 0, NULL}, /* Shift */
	{56, 0, NULL}, /* Alt Left */
	{100, 0, NULL}, /* Alt Right */
	{2, 0, "1"}, /* 1 */
	{2, Alt_Right, "¹"}, /* 1 superscript */
	{2, Shift, "!"}, /* Exclamation mark */
	{3, 0, "2"}, /* Key 2 */
	{3, Alt_Right, "²"}, /* 2 superscript */
	{4, 0, "3"}, /* Key 3 */
	{4, Alt_Right, "³"}, /* 3 superscript */
	{4, Shift, "§"}, /* Paragraph */
	{5, 0, "4"}, /* Key 4 */
	{5, Alt_Right, "¼"}, /* oe Capital ligature */
	{5, Shift, "$"}, /* Dollar sign */
	{6, 0, "5"}, /* Key 5 */
	{6, Alt_Right, "½"}, /* oe Ligature */
	{6, Shift, "%"}, /* Percent */
	{7, 0, "6"}, /* Key 6 */
	{7, Alt_Right, "¬"}, /* Negation sign */
	{7, Shift, "&"}, /* Ampersand */
	{8, 0, "7"}, /* Key 7 */
	{8, Alt_Right, "{"}, /* Opening brace */
	{8, Shift, "/"}, /* Slash */
	{9, 0, "8"}, /* Key 8 */
	{9, Alt_Right, "["}, /* Opening square bracket */
	{9, Shift, "("}, /* Opening parentheses */
	{10, 0, "9"}, /* Key 9 */
	{10, Alt_Right, "]"}, /* Closing square bracket */
	{10, Shift, ")"}, /* Closing parentheses */
	{11, 0, "0"}, /* Key 0 */
	{11, Alt_Right, "}"}, /* Closing brace */
	{11, Shift, "="}, /* Equal sign */
	{41, 0, "^"}, /* Caret */
	{41, Alt_Right, "¬"}, /* Negation */
	{41, Shift, "°"}, /* Degree */
	{0, 0, "'"}, /* Accent */
	{0, Shift, "`"}, /* Accent backward */
	{27, 0, "+"}, /* Plus */
	{27, Alt_Right, "~"}, /* Tilde */
	{27, Shift, "*"}, /* Asterisk */
	{43, 0, "#"}, /* Hash */
	{43, Alt_Right, "`"}, /* Accent backward */
	{43, Shift, "'"}, /* Single quote */
	{86, 0, "<"}, /* Greater than */
	{86, Alt_Right, "|"}, /* Pipe */
	{86, Shift, ">"}, /* Smaller than */
	{51, 0, ","}, /* Comma */
	{51, Alt_Right, "?"}, /* Question mark */
	{51, Shift, ";"}, /* Semi-colon */
	{52, 0, "."}, /* Dot */
	{52, Alt_Right, "·"}, /* Dot centered */
	{52, Shift, ":"}, /* Colon */
	{53, 0, "-"}, /* Hyphen */
	{53, Shift, "_"}, /* Underscore */
	{12, 0, "ß"}, /* sz Ligature */
	{12, Shift, "?"}, /* Question mark */
	{57, 0, " "}, /* Space bar */
	{16, 0, "q"}, /*  */
	{16, Shift, "Q"}, /*  */
	{16, Alt_Right, "@"}, /*  */
	{17, 0, "w"}, /*  */
	{17, Shift, "W"}, /*  */
	{18, 0, "e"}, /*  */
	{18, Shift, "E"}, /*  */
	{18, Alt_Right, "¤"}, /*  */
	{18, Accent, "é"}, /*  */
	{18, Accent_backward, "è"}, /*  */
	{18, Caret, "ê"}, /*  */
	{18, Accent_Shift, "É"}, /*  */
	{18, Accent_backward_Shift, "È"}, /*  */
	{18, Caret_Shift, "Ê"}, /*  */
	{19, 0, "r"}, /*  */
	{19, Shift, "R"}, /*  */
	{19, Alt_Right, "¶"}, /*  */
	{19, Alt_Right_Shift, "®"}, /*  */
	{20, 0, "t"}, /*  */
	{20, Shift, "T"}, /*  */
	{21, 0, "z"}, /*  */
	{21, Shift, "Z"}, /*  */
	{22, 0, "u"}, /*  */
	{22, Shift, "U"}, /*  */
	{22, Accent, "ú"}, /*  */
	{22, Accent_backward, "ù"}, /*  */
	{22, Caret, "û"}, /*  */
	{22, Accent_Shift, "Ú"}, /*  */
	{22, Accent_backward_Shift, "Ù"}, /*  */
	{22, Caret_Shift, "Û"}, /*  */
	{23, 0, "i"}, /*  */
	{23, Shift, "I"}, /*  */
	{23, Accent, "í"}, /*  */
	{23, Accent_backward, "ì"}, /*  */
	{23, Caret, "î"}, /*  */
	{23, Accent_Shift, "Í"}, /*  */
	{23, Accent_backward_Shift, "Ì"}, /*  */
	{23, Caret_Shift, "Î"}, /*  */
	{24, 0, "o"}, /*  */
	{24, Shift, "O"}, /*  */
	{24, Alt_Right, "ø"}, /*  */
	{24, Alt_Right_Shift, "Ø"}, /*  */
	{24, Tilde, "õ"}, /*  */
	{24, Tilde_Shift, "Õ"}, /*  */
	{24, Accent, "ó"}, /*  */
	{24, Accent_backward, "ò"}, /*  */
	{24, Caret, "ô"}, /*  */
	{24, Accent_Shift, "Ó"}, /*  */
	{24, Accent_backward_Shift, "Ò"}, /*  */
	{24, Caret_Shift, "Ô"}, /*  */
	{25, 0, "p"}, /*  */
	{25, Shift, "P"}, /*  */
	{25, Alt_Right, "þ"}, /*  */
	{25, Alt_Right_Shift, "Þ"}, /*  */
	{26, 0, "ü"}, /*  */
	{26, Shift, "Ü"}, /*  */
	{30, 0, "a"}, /*  */
	{30, Shift, "A"}, /*  */
	{30, Alt_Right, "æ"}, /* ae Ligature */
	{30, Alt_Right_Shift, "Æ"}, /* ae Capital ligature */
	{30, Tilde, "ã"}, /*  */
	{30, Tilde_Shift, "Ã"}, /*  */
	{30, Accent, "á"}, /*  */
	{30, Accent_backward, "à"}, /*  */
	{30, Caret, "â"}, /*  */
	{30, Accent_Shift, "Á"}, /*  */
	{30, Accent_backward_Shift, "À"}, /*  */
	{30, Caret_Shift, "Â"}, /*  */
	{31, 0, "s"}, /*  */
	{31, Shift, "S"}, /*  */
	{31, Alt_Right, "ß"}, /*  */
	{32, 0, "d"}, /*  */
	{32, Shift, "D"}, /*  */
	{32, Alt_Right, "ð"}, /*  */
	{32, Alt_Right_Shift, "Ð"}, /*  */
	{33, 0, "f"}, /*  */
	{33, Shift, "F"}, /*  */
	{34, 0, "g"}, /*  */
	{34, Shift, "G"}, /*  */
	{35, 0, "h"}, /*  */
	{35, Shift, "H"}, /*  */
	{36, 0, "j"}, /*  */
	{36, Shift, "J"}, /*  */
	{37, 0, "k"}, /*  */
	{37, Shift, "K"}, /*  */
	{38, 0, "l"}, /*  */
	{38, Shift, "L"}, /*  */
	{39, 0, "ö"}, /*  */
	{39, Shift, "Ö"}, /*  */
	{40, 0, "ä"}, /*  */
	{40, Shift, "Ä"}, /*  */
	{44, 0, "y"}, /*  */
	{44, Shift, "Y"}, /*  */
	{44, Alt_Right, "«"}, /*  */
	{44, Accent, "ý"}, /*  */
	{44, Accent_Shift, "Ý"}, /*  */
	{45, 0, "x"}, /*  */
	{45, Shift, "X"}, /*  */
	{45, Alt_Right, "»"}, /*  */
	{46, 0, "c"}, /*  */
	{46, Shift, "C"}, /*  */
	{46, Alt_Right, "¢"}, /*  */
	{46, Alt_Right_Shift, "©"}, /*  */
	{46, Accent, "ç"}, /*  */
	{46, Accent_Shift, "Ç"}, /*  */
	{47, 0, "v"}, /*  */
	{47, Shift, "V"}, /*  */
	{48, 0, "b"}, /*  */
	{48, Shift, "B"}, /*  */
	{49, 0, "n"}, /*  */
	{49, Shift, "N"}, /*  */
	{49, Tilde, "ñ"}, /*  */
	{50, 0, "m"}, /*  */
	{50, Shift, "M"}, /*  */
	{50, Alt_Right, "µ"}, /*  */
	{-1, 0, NULL}
};

/* Composite key table */
const struct modifier modifiermap[] =
{
	{Accent_backward, 42, Accent_backward_Shift},
	{Accent_backward, 54, Accent_backward_Shift},
	{Accent_backward, 58, Accent_backward_Shift},
	{Alt_Right, 42, Alt_Right_Shift},
	{Alt_Right, 54, Alt_Right_Shift},
	{Alt_Right, 58, Alt_Right_Shift},
	{Tilde, 42, Tilde_Shift},
	{Tilde, 54, Tilde_Shift},
	{Tilde, 58, Tilde_Shift},
	{Caret, 42, Caret_Shift},
	{Caret, 54, Caret_Shift},
	{Caret, 58, Caret_Shift},
	{Accent, 42, Accent_Shift},
	{Accent, 54, Accent_Shift},
	{Accent, 58, Accent_Shift},
	{0, 42, Shift},
	{0, 54, Shift},
	{0, 58, Shift},
	{Shift, 0, Accent_backward},
	{Alt_Right, 43, Accent_backward},
	{0, 100, Alt_Right},
	{Alt_Right, 27, Tilde},
	{0, 41, Caret},
	{0, 0, Accent},
	{0, -1, 0}
};

/* Volatile modifiers */
const int volatilemap[] =
{
	Caret_Shift,
	Accent_backward,
	Accent_backward_Shift,
	Accent_Shift,
	Tilde,
	Tilde_Shift,
	Caret,
	Accent,
	0
};

/* Feed this function with all raw keycodes. */
/* If the return value is > 0: beleza, we got an unicode string */
/* If it returns zero: composite key activated, needs more input */
/* If the return value is < 0: control key pressed, proceed with toolkit conversion */

int keymap_get_key(int value, int press)
{
	int utf8code, unicode, digit;
	char *code = NULL;
	static int modifier = 0;

	/* If key is released, we can only downgrade our modifier combination */
	if(!press)
	{
		if(!modifier) return 0;
		for(int j = 0; volatilemap[j] > 0; j++)
			if(volatilemap[j] == modifier)
				press = 1;
		if(press) return 0;
		for(int i = 0; modifiermap[i].keycode >= 0; i++)
		{
			if(modifiermap[i].keycode == value)
			{
				if(modifiermap[i].mod == modifier)
				{
					modifier = modifiermap[i].oldmod;
					return 0;
				}
			}
		}
	}

	/* First, look for modifier key combinations */
	for(int i = 0; modifiermap[i].keycode >= 0; i++)
	{
		if(modifiermap[i].keycode == value)
		{
			if(modifiermap[i].oldmod == modifier)
			{
				modifier = modifiermap[i].mod;
				return 0;
			}
		}
	}

	/* Second, check if the key fits the current modifier */
	for(int i = 0; compositemap[i].keycode >= 0; i++)
	{
		if(compositemap[i].keycode == value)
		{
			if(compositemap[i].mod == modifier)
			{
				code = compositemap[i].modcode;
				for(int j = 0; volatilemap[j] > 0; j++)
					if(volatilemap[j] == modifier)
						modifier = 0;
			}
		}
	}

	/* Third, if it does not, deactivate the modifier */
	if(!code)
	{
		modifier = 0;
		for(int i = 0; compositemap[i].keycode >= 0; i++)
		{
			if(compositemap[i].keycode == value)
			{
				if(compositemap[i].mod == modifier)
				{
					code = compositemap[i].modcode;
				}
			}
		}
	}

	/* Fourth, if it does still not, we got a control key */
	if(!code) return -1;

	/* Fifth, if we got a character key instead, convert to utf-8 */
	utf8code = 0;
	digit = 1;
	for(int i = 0; code[i]; i++)
	{
		utf8code += ((unsigned char)code[i]) * digit;
		digit *= 256;
	}

	/* Sixth, make it true unicode */
	if(digit == 65536)
		unicode = ((utf8code & 0x1F) << 6) + ((utf8code & 0x3F00) >> 8);
	else
		unicode = utf8code;

	return unicode;
}
