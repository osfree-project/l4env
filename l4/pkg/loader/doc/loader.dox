/*! file doc/loader.dox
 *
 * \brief Mainpage
 */

/*!
  \mainpage L4 Loader User Manual
 
\section p_intro Overview

The L4 loader can be used to start L4 applications at runtime. 
Applications can use services
of shared libraries which are loaded together with the executables.
The Loader distinguishes between \b Sigma0-style L4 tasks and \b Loader-style
L4 tasks:
- Sigma0-style L4 tasks are completely paged using the \e Sigma0
  \e protocol. The Loader (partly) replaces the RMGR functionality. A
  well-known example of a Sigma0-style task is L<sup>4</sup>Linux. 
  Sigma0-style tasks can also use services of the L4 environment.
- Loader-style L4 tasks use the L4 environment to allocate resources. They
  depend on the shared library \b libloader.s.so containing the runtime
  library which does some initializations (including the L4 environment)
  \b before the task starts (see Loader reference manual for details).

  The advantages of the Loader mode are
  -# The runtime library and therefore the region manager itself is
     relocatable.
  -# The program's pager has to page only the runtime library. All other 
     program sections are paged by the region manager of the runtime library.
  -# The program gets the \e L4Env \e infopage passed. This contains
     some system information, the default dataspace manager,
     default stack sizes and the default file provider. These parameters 
     and therefore the behavior of the application can be changed by the
     loader.
\note The preferred mode is still the Sigma0 mode since that mode is
more extensive tested.


\section p_usage Usage

The loader application itself has to be loaded by the \e GRUB \e bootloader
and started by the \c rmgr. It depends on functionalities of the DROPS servers
(see \ref p_example "example"):
- \c rmgr (resource manager)
- \c names (name server)
- \c log (log server)
- \c dm_phys (dataspace manager)
- \c simple_ts (task server)
- \c l4exec (executable interpreter)

The executable interpreter \c l4exec loads the binaries from a \e file
\e provider and creates appropriate dataspaces containing the program
sections. This server can only interprete ELF32 binaries.

An L4 task is started either directly by specifying the filename or by
using a \ref p_script "Loader config script". The latter method allows to
pass additional constraints. All file I/O is done using a file manager
which has to specified when opening the file
(see the \ref idl_open "Loader IDL interface").

The script or filename can be sent to the Loader either by using the
L<sup>4</sup>Linux utility \ref r_run_l4 "run-l4" or by using an
L4 program \ref a_run "run".

\section p_example Examples

There are two examples:
 -# A \ref p_hello_page "simple example" starting hello.
 -# An \ref p_tut_page "advanced tutorial" on how to boot L<sup>4</sup>Linux
    and start the MPEG viewer (not part of the basic DROPS distribution)
    parallel to L<sup>4</sup>Linux.

*/

/*!
\page p_hello_page Example: Starting Hello

The easiest way to start an L4 application using the L4 loader is to
pass the name of the executable as command line argument to the loader:

\verbatim
 title Fiasco, loader, run
 kernel (nd)/tftpboot/fm3/rmgr -sigma0
 modaddr 0x02000000
 module (nd)/tftpboot/fm3/fiasco
 module (nd)/tftpboot/fm3/sigma0
 module (nd)/tftpboot/fm3/log
 module (nd)/tftpboot/fm3/names
 module (nd)/tftpboot/fm3/dm_phys
 module (nd)/tftpboot/fm3/tftp
 module (nd)/tftpboot/fm3/simple_ts
 module (nd)/tftpboot/fm3/l4exec
 module (nd)/tftpboot/fm3/loader (nd)/tftpboot/fm3/hello
\endverbatim

\note The default file provider the loader communicates with is tftp. This
server accepts filenames in the GRUB syntax. Therefore you must prepend
\c "(nd)/". The binary must be accessable by the TFTP protocol (e.g. the
binaries must be readable by world).

*/

/*!
\page p_tut_page Tutorial: Loading L4Linux 2.2

To explain how to use the L4 loader, we will analyse here a more practical
scenario. We will start L<sup>4</sup>Linux as development environment. Once L<sup>4</sup>Linux is
up we can start/kill L4 tasks using the Linux utilities \ref r_run_l4 "run-l4"
and \ref r_kill_l4 "kill-l4".

\ref p_tut_1

\ref p_tut_2

\ref p_tut_3

\ref p_tut_4

\ref p_tut_5
*/

/*! \page p_tut_1 Step 1: Start L4Linux 2.2

We have to take some special care to be able to load L<sup>4</sup>Linux because this
applications is (currently) Sigma0-paged and has some requirements:
- the program sections has to be mapped one-by-one
- there should be some memory available which can be used for ISA-DMA,
  at least 2 MB (4 MB recommended)
- there should be some more memory available, at least 16 MB (48 MB
recommended)

To meet the memory requirements, we reserve a special pool at the dm_phys
dataspace manager. The pool number is important because the execution
layer trys to allocate direct-mapped memory from memory pool 1 (this 
is to subject of change in future versions). The pool number 7 is reserved
for memory which is located below 16 MB.

Here is the GRUB \c menu.lst entry assuming that GRUB loads the binaries via
network from a user fm3:

\verbatim
 title Fiasco, loader, L4Linux
 kernel (nd)/tftpboot/fm3/rmgr -sigma0 task modname "glinux"
 modaddr 0x02000000
 module (nd)/tftpboot/fm3/fiasco -serial_esc -nokdb -nowait
 module (nd)/tftpboot/fm3/sigma0
 module (nd)/tftpboot/fm3/log
 module (nd)/tftpboot/fm3/names
 module (nd)/tftpboot/fm3/dm_phys --pool=1,0x00410000,0x003ff000,0x00800000,linux --isa==0x00400000,0x00700000,0x01000000
 module (nd)/tftpboot/fm3/tftp
 module (nd)/tftpboot/fm3/con
 module (nd)/tftpboot/fm3/simple_ts
 module (nd)/tftpboot/fm3/l4exec
 module (nd)/tftpboot/fm3/loader (nd)/tftpboot/fm3/cfg_run
 vbeset 0x117
\endverbatim

Loader \e config script:
\verbatim
 # cfg_linux

 verbose 0
 fiasco_symbols 1
 fiasco_lines 1

 modpath "(nd)/tftpboot/fm3/pub"

 task "glinux" "root=/dev/hda1" direct_mapped
   memory  4 MB is [ dmaable ]
   memory 64 MB is [ contiguous ]
\endverbatim

\note The \b vbeset command switches into graphic mode after loading
all L4 boot modules. The L4 console assumes that a graphic mode is
active and determines the mode properties using the \e multiboot \e info
\e structure. See documentation of the \c con package for further
details.

\note L<sup>4</sup>Linux has to be compiled with the L<sup>4</sup>Linux option 
<i>"Connect to DROPS console"</i>.

\note The default file provider the loader communicates with is tftp. This
server accepts filenames in the GRUB syntax. Therefore you must prepend
\c "(nd)/". The binary must be accessable by the TFTP protocol (e.g. the
binaries must be readable by world).

\note The \c tftp server acts as a \e file \e provider. The server cannot
work anymore as soon as L<sup>4</sup>Linux initializes it's own network driver.
Therefore we can't use the tftp server as file provider in parallel to 
L<sup>4</sup>Linux. Instead, we have to use an L<sup>4</sup>Linux task for
this purpose. See next step.

\note To save memory, we could inhibit to load debugging information
by setting \b fiasco_symbols and \b fiasco_lines to 0. Especially the
fiasco_lines need much space on big L4 tasks.

<br>
\ref p_tut_2
*/

/*! \page p_tut_2 Step 2: Start MPEG viewer from L4Linux

Now the L<sup>4</sup>Linux environment should be available and we can login. Because
the \b tftp server doesn't work anymore (L<sup>4</sup>Linux has occupied the network
card), we have to start an another file provider (\b fprov-l4) running as
a Linux task:

\verbatim
 ssh christian
 cd /home/fm3/boot/linux
 ./fprov-l4
\endverbatim

After that, we can start L4 tasks using the \b run-l4 Linux program:

\verbatim
ssh christian
cd /home/fm3/boot/pub/linux
./run-l4 cfg_vesaview
logout
\endverbatim

Loader \e config script:
\verbatim
 # cfg_vesaview

 verbose 0
 fiasco_symbols 1
 fiasco_lines 1

 modpath "/home/fm3/boot"
 libpath "/home/fm3/boot/lib"

 task "bootmod"
   module "mpeg/python_352.vid" "video"

 task "vesaview" "video -heap=0x00600000 -noloop"
\endverbatim

\note This is only an example. Instead of starting the \b bootmod server,
we could pass the mpeg file as a boot module to vesaview. But if we
would start more instances of vesaview in parallel, the \b bootmod server
would save memory because the video would be loaded only once. Passing
the video as boot module to every instance would load the file multiple
times.

\note The \b "-noloop" switch for vesaview is essential here. If we wouldn't
pass it to vesaview, the task would run in a loop consuming much CPU time.
On a PPro 200, the mpeg player would consume \b all CPU time so we would
not have any change to stop the L4 task!

Now, after the MPEG viewer has shown the mpeg video one time, the
L4 task stops (sleeping forever).

\ref p_tut_3
*/

/*! \page p_tut_3 Step 3: Dump program sections of L4 task
Lets determine which L4 tasks we have started on the target machine. To
do this, we login and start an L<sup>4</sup>Linux task which retrieves the
information from the loader:
\verbatim
ssh christian
cd /home/fm3/boot/pub/linux
./dump-l4 0
logout
\endverbatim


We get the following (or similar) output:
\verbatim
Task "glinux", #e
    0 ds  -1: 003ff000-0053f000 rwx link attach beg
      ds  -1: 00540000-005a0000 rwx attach end
Task "bootmod", #f
    0 ds  17: 00e00000-00e5c000 rwx link attach beg end
Task "vesaview", #10
    0 ds  26: 00700000-00775000 rwx beg end
    1 ds  25: 0000e000-0000f000 r-x share beg
      ds  37: 0000f000-00010000 rw- share end
    2 ds  38: 00010000-0001e000 r-x share beg
      ds  39: 0001e000-00035000 rw- share end
    3 ds  40: 00035000-0003a000 r-x attach share beg
      ds  41: 0003a000-00042000 rw- share end
    4 ds  42: 00042000-00047000 r-x attach share beg
      ds  43: 00047000-0004a000 rw- share end
    5 ds  44: 00001000-00003000 r-x attach share beg
      ds  45: 00003000-00004000 rw- share end
\endverbatim

\ref p_tut_4
*/

/*! \page p_tut_4 Step 4: Dump memory usage of L4 tasks
There is also an L<sup>4</sup>Linux task which dumps the memory map of
the \b simple_dm dataspace manager:

\verbatim
ssh christian
cd /home/fm3/boot/pub/linux
./dump-ds 0
logout
\endverbatim

\note The \b "0" argument of dump-ds means to dump the dataspaces
of all tasks. Alternate, we could request memory information about
a specific L4 task by passing it's task number.

We get the following (or similar) output:

\verbatim
    0: size=00001000  client=c.0  name="libthread memory"
    1: size=00020000  client=c.0  name="libthread memory"
    2: size=00001000  client=9.0  name="libthread memory"
    3: size=00020000  client=9.0  name="libthread memory"
    4: size=00020000  client=c.2  name="application heap"
    5: size=00001000  client=a.0  name="libthread memory"
    6: size=00020000  client=a.0  name="libthread memory"
    7: size=00001000  client=b.0  name="libthread memory"
    8: size=00020000  client=b.0  name="libthread memory"
    9: size=00008000  client=a.2  name="tftp netbuff"
   10: size=00400000  client=b.2  name="application heap"
   11: size=00020000  client=c.2  name="libthread memory"
   12: size=00001000  client=c.2  name="infopage"
   13: size=00002000  client=c.2  name="trampoline page"
   14: size=00037000  client=b.2  name="symbols"
   15: size=00001000  client=c.2  name="infopage"
   16: size=00002000  client=c.2  name="trampoline page"
   17: size=0005c000  client=b.2  name="psec bootmod"
   18: size=00160000  client=64.0  name="python_352.vid"
   19: size=00008000  client=b.2  name="symbols"
   20: size=00015000  client=b.2  name="debug lines"
   21: size=00001000  client=c.2  name="infopage"
   22: size=00001000  client=f.0  name="libthread memory"
   23: size=00020000  client=f.0  name="libthread memory"
   24: size=00040000  client=f.2  name="application heap"
   25: size=00001000  client=b.2  name="cow of ds 27"
   26: size=00075000  client=b.2  name="psec vesaview"
   27: size=00001000  client=b.2  name="psec libloader.s.so"
   28: size=00001000  client=b.2  name="psec libloader.s.so"
   29: size=0000e000  client=b.2  name="psec libl4rm_s.so"
   30: size=00017000  client=b.2  name="psec libl4rm_s.so"
   31: size=00005000  client=b.2  name="psec libl4env_s.so"
   32: size=00008000  client=b.2  name="psec libl4env_s.so"
   33: size=00005000  client=b.2  name="psec libyuv2rgb_s.s"
   34: size=00003000  client=b.2  name="psec libyuv2rgb_s.s"
   35: size=00002000  client=b.2  name="psec libbootmod_s.s"
   36: size=00001000  client=b.2  name="psec libbootmod_s.s"
   37: size=00001000  client=b.2  name="cow of ds 28 (cp)"
   38: size=0000e000  client=b.2  name="cow of ds 29"
   39: size=00017000  client=b.2  name="cow of ds 30 (cp)"
   40: size=00005000  client=b.2  name="cow of ds 31"
   41: size=00008000  client=b.2  name="cow of ds 32 (cp)"
   42: size=00005000  client=b.2  name="cow of ds 33"
   43: size=00003000  client=b.2  name="cow of ds 34 (cp)"
   44: size=00002000  client=b.2  name="cow of ds 35"
   45: size=00001000  client=b.2  name="cow of ds 36 (cp)"
   46: size=00002000  client=c.2  name="trampoline page"
   47: size=00016000  client=b.2  name="symbols"
   48: size=00038000  client=b.2  name="debug lines"
   49: size=00001000  client=10.0  name="libthread memory"
   50: size=00020000  client=10.0  name="libthread memory"
   51: size=00600000  client=10.2  name="application heap"
   52: size=00020000  client=10.2  name="libthread memory"
   53: size=00020000  client=10.3  name="libthread memory"
   54: size=00001000  client=c.2  name="l4loader_info ds"
   55: size=00001000  client=67.0  name="l4_dm_dump data"
 ===========================================================
 total size=00eea000 (15272kB)
\endverbatim

\ref p_tut_5
*/

/*! \page p_tut_5 Step 5: Kill L4 task
An terminated L4 task does not automatically release all resources it
uses but we have to kill it explicitly. The \e exit() function of the
OSKit support libraries does nothing else than going into \e l4_sleep()
forever.

\todo Kill L4 task automatically on exit() when started by L4 loader.

\verbatim
 ssh christian
 cd /home/fm3/boot/pub/linux
 ./kill-l4 0x10
\endverbatim

*/

/*! \page p_script The Loader Script


\section s_misc General Control Commands.
\par verbose <0|1>
Set verbose level of config file scanner.

\par fiasco_symbols <0|1>
<i>Fiasco extension</i><br>
Try to load the symbols of the ELF binary into the iasco kernel debugger.

\par fiasco_lines <0|1>
<i>Fiasco extension</i><br>
Try to load the ELF line information into the Fiasco kernel debugger.

\par memdump
Let \c rmgr dump information about memory usage.

\par sleep <time_spec>
Do nothing for a while (useful for demos).


\section s_path Path Declarations
\par modpath "<path>"
Set default search path for modules belonging to a specific L4 task.
It may contain several directories separated by colons.

\par binpath "<path>"
Set default path where to search for binaries. If not set,
the loader searches binaries in the directory described by modpath.

\par libpath "<path>"
Set default path where to search for shared libraries. If this path
is not set, the loader searches shared libraries in the directory which
is described by binpath.


\section s_task_desc Task Description

\par task "<task_name>" ["<task_arguments>"] [<task_constraints>] [<task_modules>]
Start the description of an L4 task. <i><task_name></i> is the logical file
name of the binary. It will passed as argv[0] to the task. The string
<i>task_arguments</i> describes the command line to pass to the task as
argv[1-n]. It may be ommitted. The arguments are stored in the task's
multiboot info structure. The file name and the command line has to
be quoted.


\section s_task_modules Passing additional modules to an L4 task.
\par module "<module_name>" ["<module_arguments>"]
Specify a module that is loaded and passed to the L4 task.
<i><module_name></i> denotes the logical file name which should be load
using the file provider. If it doesn't contain a directory (that is it
doesn't start with '<i>(</i>' or '<i>/</i>') then it will be searched in all
directories of the <i>modpath</i> (see description of <i>modpath</i> above).
The module name is \b not passed to the module.
<br>
The string <i><module arguments></i> is passed completely as command line to
the module. It may contain one ore more arguments separated by spaces. The
module name and the module arguments has to be quoted.
<br>
A task finds additional modules by looking at her multiboot info structure.
The following information can be find there (see the
\ref struct_grub_mod_list "grub module info"):
- start address
- end address
- address of command line (corresponds to <i>module_arguments</i>)



\section task_constraints Additional Task Constraints

\par direct_mapped
  Only makes sense on Sigma0-style applications.
  <br>
  All loadable program sections of the binary should be loaded direct
  mapped, that is the virtual and the physical addresses are identical.

\par rebootable
  Allows the application to reboot the machine.
  <br>
  <i>Subject of future changes.</i>
  <br>
  In regular case, an application which wants to reboot the machine
  does some magic calling the BIOS reboot routine. L<sup>4</sup>Linux has
  included a special feature: Before calling BIOS reboot, it releases a
  pagefault  at address 0x3ffff000. This is the signal for the loader that
  L<sup>4</sup>Linux want's to reboot.
 
\par no_sigma0
  Don't handle sigma0 requests. This is necessary if a task is linked
  to an address above 1GB (0x40000000) because such an address would be
  interpreted as a request to an adapter page of addr+0x40000000 (see
  sigma0 protocol at L4 reference manual.

\par no_vga
  Don't map the VGA area into the application. Instead map a dummy page
  preventing the application from garbage our screen.

\par memory <size> [ is '[' <mem_flags> ']' ]
  Specifies how much memory the application should retrieve by Sigma0 protocol.
  Needed to start L<sup>4</sup>Linux. If dmaable is given, the memory should
  lay below 16 MB.

\section mem_flags Flags for Memory Regions

\par dmaable
  Ensure that the memory is direct mapped and lays below 16MB.

\par contiguous
  Ensure that the memory is physically contiguous. That does not mean
  that the memory has to be direct mapped.

\par direct_mapped
  Ensure that the memory is direct mapped, that is the physical and the
  virtual addresses are equal.

*/

/*! \page p_utilities Utilities

\section r_run run
Start an L4 task. This is a small interactive application using a simple
syntax.

\section r_run_l4 run-l4
Start an L4 task from L<sup>4</sup>Linux using the L4 loader.
<br>
\param "<config script>"  script describing special properties of the 
application to start.

This utility is used to start L4 programs from L<sup>4</sup>Linux. The 
\ref p_script "script" is interpreted by the L4 loader.


\section r_kill_l4 kill-l4
Kill an L4 task.
<br>
\param "<l4 task number>" number of the L4 task to kill.

The task to kill must has be previously loaded by the loader.


\section r_fprov_l4 fprov-l4
File provider running on L<sup>4</sup>Linux. This program serves
file requests by reading them from the local Linux file system.
There are no parameters.

\section r_dump_l4 dump-l4
Show L4 tasks which are loaded by the L4 loader.

*/

/*! \page p_libloader Mechanism to load New-Style applications

Loader-Style L4 applications are dynamic linked against the libloader.s.so.
This library consists the basic L4 environment services which are needed 
to start an L4 application:
- the L4 region manager
- the thread library
- the semaphore library
- the name server stub
- the logserver library

When an L4 task is starting, the services (l4rm, l4thread, l4emaphore)
are get initialized and the program sections of the binary and dynamic 
libraries are attached. After all the basic initialization is done, the 
multiboot_main() function is called. If the binary does not provides such 
a function, the main() function is called instead.

*/

/*! \page p_doc About this documentation

This documentation was created using Doxygen, a source-code documentation
system.


\par Requires:
OSKit 1.0, rmgr, names, l4util, l4sys, Flick, L4 environment
\author		Frank Mehnert
*/

