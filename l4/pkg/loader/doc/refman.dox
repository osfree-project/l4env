/*! file doc/general1.dox
 *
 * \brief Mainpage
 */

/*!\mainpage LOADER - L4 loader

\section p_intro Overview

The L4 loader can be used to start L4 tasks. The tasks can use services
of shared libraries which will be auto-loaded when the task is loaded. 
The Loader distinguishes between old-style L4 tasks and new-style L4 tasks:
- Old-style L4 tasks will be completely paged using the \e Sigma0
  \e protocol. The Loader (partly) replaces the RMGR functionality. A 
  well-known example of an old-style task is L4Linux.
- New-style L4 tasks use the L4 environment to allocate resources. Such
  an application depends on the shared library \b libloader.s.so which
  does some \ref p_new_style "initializations" (including the L4 environment) 
  before the task starts. There is an \ref p_libloader "description" of the 
  load process of this type of application.

The loader application itself has to be bootet by the GRUB bootloader.
It depends on the servers \b rmgr, \b log, \b names, \b dm_phys,
\b simple_ts, and \b l4exec (see \ref p_example). To load and interprete 
binaries, the loader uses services of an execution layer (\b l4exec server). 
Currently, the l4exec server can only interpret ELF32 binaries.

\section s_types Which types of programs the Loader cannot handle?
- programs that use the rmgr_reserve_mem call

An L4 task is started by using a \ref p_script "Loader config script".

The script can be sent to the Loader either by using the L4Linux utility
\ref r_run_l4 "run-l4" or by using an L4 program \ref a_run "run" .

\ref p_doc


\section p_tut Tutorial
To explain how to use the L4 loader, we will analyse a practical scenario.
We will start L4Linux as development environment. Once L4Linux is up, we can
start/kill L4 tasks using the Linux utilities \ref r_run_l4 "run-l4" and
\ref r_kill_l4 "kill-l4".

\ref p_tut_1

\ref p_tut_2

\ref p_tut_3

\ref p_tut_4

\ref p_tut_5
*/

/*! \page p_tut_1 Step 1: Start L4Linux
We have to take some special care to be able to load L4Linux because this
applications is (currently) Sigma0-paged and depends on some requirements:
- the program sections has to be mapped one-by-one
- there should be some memory available which can be used for ISA-DMA,
  at least 2 MB
- there should be some more memory available, at least 16 MB

To meet the memory requirements, we reserve a special pool at the dm_phys
dataspace manager. The pool number is important because the execution
layer trys to allocate direct-mapped memory from memory pool 1. The
pool number 7 is reserved for memory which lays below 16 MB.

Grub menu.lst entry:

\verbatim
title Fiasco, loader, L4Linux
kernel (nd)/tftpboot/fm3/pub/rmgr -sigma0 -symbols task modname "glinux"
modaddr 0x02000000
module (nd)/tftpboot/fm3/pub/fiasco -serial -serial_esc -nokdb -nowait
module (nd)/tftpboot/fm3/pub/sigma0
module (nd)/tftpboot/fm3/pub/fiasco_sym
module (nd)/tftpboot/fm3/pub/log
module (nd)/tftpboot/fm3/pub/names
module (nd)/tftpboot/fm3/pub/dm_phys --pool=1,0x002c0000,0x003ff000,0x006bf000,linux --isa==0x00200000,0x00700000,0x01000000
module (nd)/tftpboot/fm3/pub/simple_ts
module (nd)/tftpboot/fm3/pub/tftp
module (nd)/tftpboot/fm3/pub/l4exec
module (nd)/tftpboot/fm3/pub/loader (nd)/tftpboot/fm3/pub/cfg_run
vbeset 0x117
\endverbatim

Loader \e config script:
\verbatim
# cfg_linux

verbose 0
fiasco_symbols 1
fiasco_lines 1
  
modpath "(nd)/tftpboot/fm3/pub"
   
task "glinux" "-vesa root=/dev/sda5" direct_mapped
  memory  2 MB dma_able
  memory 20 MB
\endverbatim

\note The \b vbeset command switches into graphic mode after loading
all L4 boot tasks. Linux recognizes the video mode and opens a
frame buffer console (\b "-vesa" command line switch). This is done
to make it possible to start vesaview in parallel to L4Linux later.
\b vbeset depends on a graphics card which provides a VESA 2 compatible
BIOS.

\note The \b tftp server acts as a file provider. The server stops
working as soon as L4Linux initializes it's own network driver. Therefore
we can't use the tftp server as file provider while L4Linux is up. 
Instead, we have to use an L4Linux task for this purpose. See next step.

\note To save memory, we could inhibit to load debugging information
by setting \b fiasco_symbols and \b fiasco_lines to 0. Especially the
fiasco_lines need much space on big L4 tasks.

<br>
\ref p_tut_2
*/

/*! \page p_tut_2 Step 2: Start Vesaview from L4Linux
Now the L4Linux environment should be available and we can login into
the L4Linux machine. Because the \b tftp server doesn't work anymore, we 
have to start an own file provider (\b fprov-l4) running as a Linux task:

\verbatim
ssh christian
cd /home/fm3/boot/pub/linux
./fprov-l4
\endverbatim

After that, we can start L4 tasks using the \b run-l4 Linux program:

\verbatim
ssh christian
cd /home/fm3/boot/pub/linux
./run-l4 cfg_vesaview
logout
\endverbatim

Loader \e config script:
\verbatim
# cfg_vesaview

verbose 0
fiasco_symbols 1
fiasco_lines 1

modpath "/home/fm3/boot/pub"
libpath "/home/fm3/boot/pub/lib"

task "bootmod"
  module "mpeg/python_352.vid" "video"

task "vesaview" "video -heap=0x00600000 -noloop"
\endverbatim

\note This is only an example. Instead of starting the \b bootmod server,
we could pass the mpeg file as a boot module to vesaview. But if we
would start more instances of vesaview in parallel, the \b bootmod server
would save memory because the video would be loaded only once. Passing
the video as boot module to every instance would load the file multiple
times.

\note The \b "-noloop" switch for vesaview is essential here. If we wouldn't
pass it to vesaview, the task would run in a loop consuming much CPU time.
On a PPro 200 (christian), the mpeg player would consume \b all CPU time
so we would not have any change to stop the L4 task!

Now, after the MPEG viewer has shown the mpeg video one time, the
L4 task stops (sleeping forever). We have the chance to start L4Linux
tasks.

\ref p_tut_3
*/

/*! \page p_tut_3 Step 3: Dump program sections of L4 task
Lets determine which L4 tasks we have started on the target machine. To
do this, we login and start an L4Linux task which retrieves the information
from the loader:
\verbatim
ssh christian
cd /home/fm3/boot/pub/linux
./dump-l4 0
logout
\endverbatim


We get the following output:
\verbatim
Task "glinux", #e
    0 ds  -1: 003ff000-0053f000 rwx link attach beg
      ds  -1: 00540000-005a0000 rwx attach end
Task "bootmod", #f
    0 ds  17: 00e00000-00e5c000 rwx link attach beg end
Task "vesaview", #10
    0 ds  26: 00700000-00775000 rwx beg end
    1 ds  25: 0000e000-0000f000 r-x share beg
      ds  37: 0000f000-00010000 rw- share end
    2 ds  38: 00010000-0001e000 r-x share beg
      ds  39: 0001e000-00035000 rw- share end
    3 ds  40: 00035000-0003a000 r-x attach share beg
      ds  41: 0003a000-00042000 rw- share end
    4 ds  42: 00042000-00047000 r-x attach share beg
      ds  43: 00047000-0004a000 rw- share end
    5 ds  44: 00001000-00003000 r-x attach share beg
      ds  45: 00003000-00004000 rw- share end
\endverbatim

\ref p_tut_4
*/

/*! \page p_tut_4 Step 4: Dump memory usage of L4 tasks
There is also an L4Linux task which dumps the memory map of
the \b simple_dm dataspace manager:

\verbatim
ssh christian
cd /home/fm3/boot/pub/linux
./dump-ds 0
logout
\endverbatim

\note The \b "0" argument of dump-ds means to dump the dataspaces
of all tasks. Alternate, we could request memory information about
a specific L4 task by passing it's task number.

We get the following output:

\verbatim
    0: size=00001000  client=c.0  name="libthread memory"
    1: size=00020000  client=c.0  name="libthread memory"
    2: size=00001000  client=9.0  name="libthread memory"
    3: size=00020000  client=9.0  name="libthread memory"
    4: size=00020000  client=c.2  name="application heap"
    5: size=00001000  client=a.0  name="libthread memory"
    6: size=00020000  client=a.0  name="libthread memory"
    7: size=00001000  client=b.0  name="libthread memory"
    8: size=00020000  client=b.0  name="libthread memory"
    9: size=00008000  client=a.2  name="tftp netbuff"
   10: size=00400000  client=b.2  name="application heap"
   11: size=00020000  client=c.2  name="libthread memory"
   12: size=00001000  client=c.2  name="infopage"
   13: size=00002000  client=c.2  name="trampoline page"
   14: size=00037000  client=b.2  name="symbols"
   15: size=00001000  client=c.2  name="infopage"
   16: size=00002000  client=c.2  name="trampoline page"
   17: size=0005c000  client=b.2  name="psec bootmod"
   18: size=00160000  client=64.0  name="python_352.vid"
   19: size=00008000  client=b.2  name="symbols"
   20: size=00015000  client=b.2  name="debug lines"
   21: size=00001000  client=c.2  name="infopage"
   22: size=00001000  client=f.0  name="libthread memory"
   23: size=00020000  client=f.0  name="libthread memory"
   24: size=00040000  client=f.2  name="application heap"
   25: size=00001000  client=b.2  name="cow of ds 27"
   26: size=00075000  client=b.2  name="psec vesaview"
   27: size=00001000  client=b.2  name="psec libloader.s.so"
   28: size=00001000  client=b.2  name="psec libloader.s.so"
   29: size=0000e000  client=b.2  name="psec libl4rm_s.so"
   30: size=00017000  client=b.2  name="psec libl4rm_s.so"
   31: size=00005000  client=b.2  name="psec libl4env_s.so"
   32: size=00008000  client=b.2  name="psec libl4env_s.so"
   33: size=00005000  client=b.2  name="psec libyuv2rgb_s.s"
   34: size=00003000  client=b.2  name="psec libyuv2rgb_s.s"
   35: size=00002000  client=b.2  name="psec libbootmod_s.s"
   36: size=00001000  client=b.2  name="psec libbootmod_s.s"
   37: size=00001000  client=b.2  name="cow of ds 28 (cp)"
   38: size=0000e000  client=b.2  name="cow of ds 29"
   39: size=00017000  client=b.2  name="cow of ds 30 (cp)"
   40: size=00005000  client=b.2  name="cow of ds 31"
   41: size=00008000  client=b.2  name="cow of ds 32 (cp)"
   42: size=00005000  client=b.2  name="cow of ds 33"
   43: size=00003000  client=b.2  name="cow of ds 34 (cp)"
   44: size=00002000  client=b.2  name="cow of ds 35"
   45: size=00001000  client=b.2  name="cow of ds 36 (cp)"
   46: size=00002000  client=c.2  name="trampoline page"
   47: size=00016000  client=b.2  name="symbols"
   48: size=00038000  client=b.2  name="debug lines"
   49: size=00001000  client=10.0  name="libthread memory"
   50: size=00020000  client=10.0  name="libthread memory"
   51: size=00600000  client=10.2  name="application heap"
   52: size=00020000  client=10.2  name="libthread memory"
   53: size=00020000  client=10.3  name="libthread memory"
   54: size=00001000  client=c.2  name="l4loader_info ds"
   55: size=00001000  client=67.0  name="l4_dm_dump data"
 ===========================================================
 total size=00eea000 (15272kB)
\endverbatim

\ref p_tut_5
*/

/*! \page p_tut_5 Step 5: Kill L4 task
An terminated L4 task does not automatically release all resources it
uses but we have to kill it explicitly. The \e exit() function of the
OSKit support libraries does nothing else than going into \e l4_sleep()
forever.

\todo Kill L4 task automatically on exit() when started by L4 loader.

\verbatim
ssh christian
cd /home/fm3/boot/pub/linux
./kill-l4 0x10
\endverbatim

*/

/*! \page p_script The Loader Script


\subsection s_misc General Control Commands.

\par verbose <0|1>
Set verbose level of config file scanner.

\par fiasco_symbols <0|1>
<b>Fiasco extension</b><br>
Try to load and publish symbols of the ELF binary to Fiasco.

\par fiasco_lines <0|1>
<b>Fiasco extension</b><br>
Try to load and publish line information of the ELF binary to Fiasco.

\par memdump
Let rmgr dump information about memory usage.

\par sleep <time_spec>
Waits with executing next job for a while.


\subsection s_path Path Declarations

\par modpath <path>
Set default search path for files.

\par binpath <path>
Set default path where to search for binaries. If not set, the loader
searches binaries in the directory described by modpath.

\par libpath <path>
Set default path where to search for shared libraries. If this path
is not set, the loader searches shared libraries in the directory which
is described by binpath.


\subsection s_task_desc Task Description

\par task "<task name>" ["<arguments>"] [<task_constraints>] [<task_modules>]
Start the description of an L4 task. <i><task name></i> is the file name
of the binary. <i>arguments</i> describes the command line to pass to the 
task. The file name and the arguments has to be quoted.


\subsection s_task_modules Passing additional modules to an L4 task.
\par <module name> ["<module_arguments>"]
Specify a module that is loaded and passed to the new L4 task. 
<i><module arguments></i> are passed as command line options to the module.


\subsection task_constraints Additional task constraints.

\par direct_mapped
  Only makes sense on old-style applications.
  <br>
  All loadable program sections of the binary should be loaded direct
  mapped, that is the virtual and the physical addresses are identical.

\par reboot_able
  Allows the application to reboot the machine.
  <br>
  Subject of future changes.
  <br>
  In regular case, an application which wants to reboot the machine
  does some magic calling the BIOS reboot routine. L4Linux has included
  a special feature: Before calling BIOS reboot, it releases a pagefault
  at address 0x3ffff000. This is the signal for the loader that L4Linux
  want's to reboot.
 
\par no_sigma0
  Don't handle sigma0 requests. This is necessary if a task is linked
  to an address above 1GB (0x40000000) because such an address would be
  interpreted as a request to an adapter page of addr+0x40000000 (see
  sigma0 protocol at L4 reference manual.

\par memory <size> [ dma_able ]
Specifies how much memory the application should retrieve by Sigma0 protocol.
Needed to start L4Linux. If dma_able is given, the memory should lay below
16 MB.



\subsection p_example Example: Load four instances of vesaview
All instance access the MPEG video module.

\verbatim
# cfg_vesaview
 
verbose 1
fiasco_symbols 1
fiasco_lines 1

modpath "(nd)/tftpboot/fm3/pub"
   
task "bootmod"
  module "mpeg/python_352.vid" "video"

task "vesaview" "video -heap=0x00600000 -x=20  -y=50"
task "vesaview" "video -heap=0x00600000 -x=20  -y=300"
task "vesaview" "video -heap=0x00600000 -x=380 -y=50"
task "vesaview" "video -heap=0x00600000 -x=380 -y=300"

memdump
\endverbatim

What happens:
- set verbose level to 1 to be more verbose when scanning the config file
- enable loading and passing debugging symbols to Fiasco
- enable loading and passing lines information to Fiasco
- set module search path to "(nd)/tftpboot/fm3/pub"
- load task bootmod and pass module "(nd)/tftpboot/fm3/pub/mpeg/phython_352.vid"
- load task vesaview four times passing some command line arguments
- request memory dump by rmgr
*/

/*! \page p_new_style New-style applications

Hallo

*/


/*! \page p_utilities Linux Utilities

\section r_run_l4 run-l4
Start an L4 task from L4Linux using the L4 loader.
<br>
\param "<config script>"  script describing special properties of the 
application to start.

This utility is used to start L4 programs from L4Linux. The 
\ref p_script "script" is interpreted by the L4 loader.


\section r_kill_l4 kill-l4
Kill an L4 task.
<br>
\param "<l4 task number>" number of the L4 task to kill.

The task to kill must has be previously loaded by the loader.


\section r_fprov_l4 fprov-l4
File provider running on L4Linux.

\section r_dump_l4 dump-l4
Show L4 tasks which are loaded by the L4 loader.

*/

/*! \page p_libloader Mechanism to load New-Style applications

New-Style L4 applications are dynamic linked against the libloader.s.so.
This library consists the basic L4 environment services which are needed 
to start an L4 application:
- the L4 region manager
- the thread library
- the semaphore library
- the name server stub
- the logserver library

When an L4 task is starting, the services (l4rm, l4thread, l4emaphore)
are get initialized and the program sections of the binary and dynamic 
libraries are attached. After all the basic initialization is done, the 
multiboot_main() function is called. If the binary does not provides such 
a function, the main() function is called instead.

*/

/*! \page p_doc About this documentation

This documentation was created using Doxygen, a source-code documentation
system.


\par Requires:
OSKit 1.0, rmgr, names, l4util, l4sys, Flick, L4 environment
\author		Frank Mehnert
*/

