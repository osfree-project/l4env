\documentclass[11pt,a4paper,normalheadings,DIV14]{scrartcl}
\usepackage{times}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage[small,bf,hang]{caption2}
\usepackage{epsfig}
\usepackage{graphicx}
\emergencystretch = 10pt
\clubpenalty = 10000
\widowpenalty = 10000
\displaywidowpenalty = 10000
\usepackage{amsmath}
\usepackage{amssymb}
\begin{document}
\parskip 0.5ex
\parindent 0ex
\title{L4sig - a POSIX Signal implementation for L4Env}
\author{Bjoern Doebel \mbox{$<$}doebel@os.inf.tu-dresden.de\mbox{$>$}}
\maketitle
\tableofcontents

 %     -+*|[ INTRODUCTION ]|*+-

 \section{Introduction} \label{Introduction}
  Signals are a powerful way of asynchronous IPC on Unix and its
  derivates. However there has not been any implementation of signals
  on the DROPS operating system, mainly because DROPS´ way of IPC is based
  on synchronous communication. This document describes an implementation
  of a signal mechanism on DROPS.

  This document describes design decisions, the implementation and open issues
  concerning an implementation of POSIX signals on L4, called L4sig.

  In the beginning I will give a short overview about the environment of my
  implementation - the DROPS operating system and some of its components.
  After this I will introduce the POSIX signal mechanism and its application.
  With this background I am going to explain decisions in the design of L4sig
  that lead to my implementation. After this, I will give details about the
  implementation itself. A section about issues left open by my implementation
  and about known problems with the implementation and its environment, followed
  by an evaluation of L4sig will conclude this text.


 %     -+*|[ STATE OF THE ART ]|*+-

 \section{State of the art} \label{State of the art}


  %     -+*|[ DROPS, L4ENV AND DIETLIBC ]|*+-

  \subsection{DROPS, L4Env and dietlibc} \label{DROPS L4Env and dietlibc}

   The \textbf{Dresden Realtime Operating System (DROPS)} is an operating
   system developed at the Operating Systems Group at Dresden University
   of Technology. DROPS is based on the \textbf{Fiasco} microkernel, which is
   an implementation of the L4 microkernel interface.

   \textbf{L4Env} is a set of microkernel servers and libraries created to support
   common tasks on top of a microkernel. This includes
   task and thread creation, memory management, name resolving and many more.

   The \textbf{dietlibc} is an impementation of the Standard C Library optimized
   for small size. It has been ported to DROPS by Martin Pohlack and others
   and is aimed to be DROPS´ standard C library. An important target of the dietlibc 
   port to DROPS is to easily port UNIX software to DROPS.


  %     -+*|[ POSIX SIGNALS ]|*+-

  \subsection{POSIX signals} \label{POSIX signals}

   The POSIX.1 standard and its enhancements POSIX.1b and POSIX.1c define
   a standard signal interface. Signals are treated as ``software interrupts'',
   which means that they are delivered and handled asynchronously in respect
   to normal program operation.
    
   \newpage
   The following signals are defined by POSIX.1:

   \begin{itemize}
    \item
     \textbf{Hangup (SIGHUP)} is generated whenever a connection between an application and it´s environment is terminated.
    \item
     \textbf{Interrupt (SIGINT)} may be generated by the user using the keyboard.
    \item
     \textbf{Quit (SIGQUIT)} is a quit signal generated by the user via keyboard
    \item
     \textbf{Illegal Instruction (SIGILL)} is generated by the OS kernel whenever an illegal instruction is used.
    \item
     \textbf{Abort (SIGABRT)} is generated on abnormal program termination
    \item
     \textbf{Floating Point Error (SIGFPE)} is generated by the OS on an error
     concerning the floating point unit
    \item
     \textbf{Kill (SIGKILL)} signals a program to stop immediately. There is no choice to ignore it.
    \item
     \textbf{User signals (SIGUSR1, SIGUSR2)} are defined to provide application developers with signals that
     they may use as they like within their applications.
    \item
     \textbf{Segmentation fault (SIGSEGV)} signals an error in memory access.
    \item
     \textbf{Pipe (SIGPIPE)} is generated when a process tries to write to a pipe when no one is reading it.
    \item
     \textbf{Alarm (SIGALRM)} is sent to a process whenever the process requests it via the \texttt{alarm()} call
     provided by the standard C library
    \item
     \textbf{Terminate (SIGTERM)} is a polite way of asking an application to quit.
     In contrast to SIGKILL the application developer may chose to ignore SIGTERM.
    \item
     \textbf{Child terminated (SIGCHLD / SIGCLD)} is sent to a parent process informing
     it when one of its childs has been terminated.
    \item
     \textbf{Stop (SIGSTOP)} forces an application to stop all processing until a
     SIGCONT is received. SIGSTOP may not be ignored.
    \item
     \textbf{Continue (SIGCONT)} continues program operation on a stopped application.
    \item
     \textbf{Stop by TTY (SIGSTP)} is the same as SIGSTOP but may be ignored.
    \item
     \textbf{TTY Input (SIGTTIN)} signals input available in a TTY to background
     processes
    \item
     \textbf{TTY Output (SIGTTOU)} signals output available on a TTY to background
     processes

   \end{itemize}

  %     -+*|[ LINUX SIGNAL EXTENSIONS ]|*+-

  \subsection{Linux signal extensions} \label{Linux signal extensions}

   Linux supports nine additional signals defined by the Single UNIX Specification, Version 2
   (SUSv2):

   \begin{itemize}
    \item
     \textbf{Trap (SIGTRAP)} signals a debug trace point
    \item
     \textbf{Unused (SIGUNUSED)} is unused.
    \item
     \textbf{Stack fault (SIGSTKFLT)} signals an error in the co-processor´s stack.
    \item
     \textbf{SIGIO} signals an input--output error.
    \item
     \textbf{SIGXCPU} signals excess of a CPU time limit
    \item
     \textbf{SIGXFSZ} signals excess of a file size limit
    \item
     \textbf{SIGVTALRM} sends a virtual time alarm - even the Linux man page
     (\texttt{man 7 signal}) does not know what this signal means.
    \item
     \textbf{SIGPROF} may be used for profiling purposes.
    \item
     \textbf{SIGWINCH} signals a change of window size.

   \end{itemize}

  %     -+*|[ WORKING WITH SIGNALS ]|*+-

  \subsection{Working with signals} \label{Working with signals}

   POSIX defines three ways of handling signals:

   \begin{enumerate}
    \item
     \emph{Catching a signal} means to register a handler function for the
     signal which is called whenever the corresponding signal occurs.
     This option is however not eligible  for SIGKILL and SIGSTOP.
    \item
     \emph{Ignore a signal} and continue operation. This is option is
     not eligible for SIGKILL and SIGSTOP. This behaviour is
     achieved by setting the signal´s signal handler to SIG\_IGN.
    \item
     \emph{Terminate the process} - this is the default behaviour for most
     of the above mentioned signals.

   \end{enumerate}
   Initially all signal handlers are set to default signal handling. After
   registering a signal handler, the application programmer may return to
   default signal handling, by setting the signal handler to SIG\_DFL.

   There are 2 common prototypes for signal handling functions:

   \begin{itemize}
    \item
     \texttt{void sighandler(int signal)} - a signal handler with one argument
     only receives the number of the signal when invoked,
    \item
     \texttt{void sigaction(int signal, siginfo\_t siginfo, void *ucontext)} - a
     signal handler with 3 arguments also receives the number of the signal.
     Further parameters include a siginfo-struct containing more information
     about sepcific signals and a ucontext struct handing over an architecture
     dependant signal set.

     The \texttt{siginfo\_t} argument contains the following information:
     \begin{itemize}
      \item
       signal number,
      \item
       signal code - the origin of the signal (e.\,g. user, kernel or timer).
       Specific signals may have a more special signal code. Floating point
       exceptions for instance generate codes telling the user what type of
       FP exception occured (divide by zero, overflow, underflow, invalid
       operation, out of range...), and
      \item
       special information for signals (e.\,g. the faulting address for SIGSEGV).

     \end{itemize}
   \end{itemize}
   \newpage
   Signal handlers may be registered in two different ways:

   First of all the programmer may use the \texttt{signal()} library routine to register
   a signal handler with one argument only. For instance a handler for the
   SIGCHLD signal may be registered in the following way:

   \begin{footnotesize}
   \begin{verbatim}
    void child_handler (int signo)
    {  
        printf("SIGCHLD received.\n");
    }

    int main (int argc, char **argv)
    {
    ...
        signal(SIGCHLD, child_handler);
    ...
    }
   \end{verbatim}
   \end{footnotesize}

   Among this standard UNIX way of handling signals, POSIX defines another
   possibility using the function
   \begin{verbatim}
    int sigaction (int signum, const struct sigaction *action, 
                   struct sigaction *oldact)
   \end{verbatim}

   This function sets the sigaction struct for the signal \texttt{signum} to
   the \texttt{action} parameter and returns the old sigaction struct within
   \texttt{oldact}. The function \texttt{sigaction()} gives the user a lot of more
   possibilites, because the sigaction structs contain more than just
   a pointer to the signal handler. The developer

   \begin{itemize}
    \item
     may specify what signals shall be blocked during
     execution of this signal handler,
    \item
     may choose to set a signal handler with one \emph{or} with three
     arguments,
    \item
     set flags influencing the behaviour on signal occurence, for instance
     tell whether the signal handler should be a one shot handler and
     be reset after signal occurence.

   \end{itemize}
   An example of registering a three argument signal handler is given below:

   \begin{footnotesize}
   \begin{verbatim}
    void child_handler(int signum, siginfo_t *siginfo, void *context)
    {
       printf("Received a SIGCHLD from %d", siginfo->si_pid);
    }

    int main(int argc, char **argp)
    {
       ...
       sigset_t signal_mask;
       struct sigaction new_action;

       // query signal mask
       sigprocmask(0, NULL, &signal_mask);

       new_action.sa_sigaction = child_handler;
       new_action.sa_mask      = signal_mask;
       // flag storing the use of a 3 argument handler
       new_action.sa_flags     = SA_SIGINFO;
       sigaction(SIGCHLD, &new_action, NULL);
       ...
    }
   \end{verbatim}
   \end{footnotesize}


 %     -+*|[ DESIGN DECISIONS AND IMPLEMENTATION ]|*+-

 \section{Design decisions and implementation} \label{Design decisions and implementation}

  This part of the document describes design decisions that I
  made to implement signals for DROPS. To illustrate the steps necessary,
  I will start with an example of signal generation.


  \begin{figure}[hbp]
   \begin{center}
    \epsfig{file=example,angle=0,width=0.7\columnwidth}
    \caption{Typical scenario of L4 components working together to generate a signal}
    \label{examplepdf}
   \end{center}
  \end{figure}


  Figure \ref{examplepdf} shows how different L4 components will have to work
  together to generate a SIGWINCH signal.

  \begin{enumerate}
   \item \label{Step1}
    We start with a terminal application using L4sig. It thus is running
    a signal handler thread which at startup registers at the signal server.
    The signal server is then able to deliver signals to this terminal
    application.
   \item
    The terminal application opens a terminal. It therefore calls a
    terminal server managing the communication with the window manager
    providing a terminal widget. In this case we assume DOpE as the
    window manager of choice.
   \item
    The terminal server opens a DOpE terminal widget and registers callbacks
    for the widget´s events. As we want SIGWINCH to be generated and delivered
    to the terminal application, at least a callback \emph{r} for the resize event
    has to be registered.
   \item
    If the callback was registered correctly, DOpE will send a resize
    event to the terminal server whenever the widget has been resized. The
    callback function \emph{r} is then called.
   \item
    Function \emph{r} may now use the \texttt{kill()} call provided by L4sig
    to send SIGWINCH to the terminal application. \texttt{kill()} will
    call the signal server, which is aware of all signal handler threads.
    It then chooses the correct signal handler thread (the one belonging to the 
    terminal application) and delivers the signal.
   \item
    The terminal application's signal handler thread receives SIGWINCH and
    is able to act upon it, as it has registered a signal handler for this signal
    in step \ref{Step1}.

  \end{enumerate}

  %     -+*|[ SIGNAL MANAGEMENT ]|*+-

  \subsection{Signal management} \label{Signal management}

   Unlike in a monolithic operating system, where the kernel cares for all signal
   management, in a microkernel we need to provide signal functionality within user
   space. During development of L4sig it soon became obvious, that not all
   functionality could be implemented within a library. A library enables us
   to implement fast management of all tasks that shall be done locally for
   each thread. This includes signal blocking and management and execution of
   signal handlers.

   However, a central server is necessary to manage all applications participating
   in the signal environment. Without a server every application had to store and
   manage all known other applications locally. This is not a robust solution,
   because it forces us to save the same information multiple times. Furthermore, starting 
   and stopping an L4sig application becomes a time consuming task because it requires
   a broadcast IPC to all other tasks telling them to update their local
   signal data.

   This section describes the three main tasks of the signal server, which are:

   \begin{itemize}
    \item
     global management of signal handlers,
    \item
     delivery of signals, and
    \item
     management of alarm signals.

   \end{itemize}

   %     -+*|[ SIGNAL HANDLER MANAGEMENT ]|*+-

   \subsubsection{Signal handler management} \label{Signal handler management}
    Signal handlers register and unregister themselves at the signal server. The
    application programmer does not need to take care for registration as this
    is done at startup of each application's signal handler thread using the

    \begin{verbatim}
     int register_handler()
    \end{verbatim}


    termination the signal handler thread calls

    \begin{verbatim}
     int unregister_handler()
    \end{verbatim}

    to unregister at the signal server.

    Signals are only sent to applications having registered a signal handling
    thread while signals may be sent from all tasks.


   %     -+*|[ SIGNAL DELIVERY ]|*+-

   \subsubsection{Signal delivery} \label{Signal delivery}
    Signals are issued to the signal server using the \texttt{kill()}, \texttt{raise()} and
    \texttt{raise\_kernel()}-calls. The signal server stores them until the handling
    thread of the target application fetches them via the \texttt{receive\_signal()}
    call. As the handler thread most of the time already waits within a receive
    call, signals will be delivered as soon as possible.

    SIGKILL is a special problem for the signal server. The application shall have no
    influence on a SIGKILL. Therefore the signal server needs to terminate the
    application itself. To achieve this, the signal server first tries to abandon
    the task via a running task server. If there is no task server running or
    killing the task via the task server fails, the signal server next tries to
    exit the task via RMGR. If this also fails, it is not possible to abandon
    the task externally and we have to depend on the task's cooperation.
    SIGKILL is then delivered to the task and this will have to terminate itself.


   %     -+*|[ ALARM GENERATION ]|*+-

   \subsubsection{Alarm generation} 
    \label{Alarms}
    Applications may request to be sent SIGALRM signal after a specific period of 
    time. To manage this, a dedicated thread exists within the signal server. 
    As signals are sent to tasks, each task may request one alarm at a time. 
    
    If an application calls \texttt{alarm()} to set up an alarm signal, the signal 
    server
    calculates the time stamp in the future, when the alarm is to be sent and
    stores it. The alarm scheduling thread runs through the list of registered
    tasks periodically and checks if one of the stored timestamps has expired.
    It then sends a SIGALRM to the task and resets the timestamp to 
    ALARM\_TIME\_INVALID.

  %     -+*|[ SIGNAL GENERATION ]|*+-

  \subsection{Signal generation} \label{Signal generation}
   In this section I will give an overview on how signals are generated
   using L4sig and separate between three slightly differing types of
   signals: userland signals, kernel signals and CPU signals.

   %     -+*|[ USERLAND SIGNALS ]|*+-

   \subsubsection{Userland signals} \label{Userland signals}
    Userland signals are signals sent and received within user space using
    the \texttt{kill()} and \texttt{raise()} library calls provided by L4sig. L4sig sends
    them via IPC to the signal server. The server then looks up the task's
    signal handler thread and delivers the signal.


   %     -+*|[ KERNEL SIGNALS ]|*+-

   \subsubsection{Kernel signals} \label{Kernel signals}
    Kernel signals are signals that are generated by kernel services in
    monolithic operating systems (e.\,g. SIGSEGV by the memory management).
    As most work of a microkernel-based operating system is performed in
    user space, these signals will now also be generated by the
    servers providing these services.

    A difference between userland and kernel signals is that the latter
    send out more information with a signal than just a number. While
    userland signals like SIGUSR1 do not contain any more information,
    kernel signals add information about their origin and their reason of
    occurence. For instance SIGCHLD sends the receiver information about
    the terminating child's UID, PID and exit status, SIGSEGV informs the
    target task about the faulting memory address causing the segmentation
    fault. This additional information may be received using the three
    argument version of a signal handler.

    L4sig provides the function

    \begin{verbatim}
     int l4signal_kill_long(pid_t, siginfo_t *);
    \end{verbatim}

    to send out kernel signals with additional information packed into a
    \texttt{siginfo\_t} structure.


   %     -+*|[ CPU SIGNALS ]|*+-

   \subsubsection{CPU signals} \label{CPU signals}
    CPU signals are special kernel signals which result from a CPU exception
    being thrown. For instance SIGILL is generated by the CPU exception
    signalling an illegal operation, SIGFPE is generated by CPU exceptions
    concerning mathematical errors (division by zero, floating point error).

    For CPU exceptions we need to register userland handlers.
    The L4 IDT management may be used for that. Unfortunately IDTs are
    managed on a per-thread-basis. Thus it is not possible to let the
    task's signal handler thread set up all the IDT's at once. The application
    developer has to manually set up CPU exception handling. The dietlibc
    backend provides the routine \texttt{l4signal\_init\_idt()} for this purpose.

    Filling in the IDT requires access to the CPU's IDT. This is emulated
    by FiascoUX, but \emph{may} lead to problems because FiascoUX relies on the
    signals generated by the underlying Linux and this will in several cases
    not ensure a mapping to the CPU exception that caused the signal.

    An example: An integer division by zero raises the CPU exception \#0
    on Intel CPUs. The Linux kernel generates a SIGFPE signal from that,
    which is correct according to the POSIX signal definition. However
    also the CPU exceptions \#16 (floating point error) and \#19 (SIMD
    floating point error) generate SIGFPE. That is why it is not possible
    to distinguish between different exception sources on FiascoUX.

    At the moment, I think it is sufficient to map a Linux signal directly
    to a POSIX signal in L4Env as long as the application is only interested
    in SIGFPE as a signal. If the application however wants to get access
    to the additional signal information on SIGFPE (which provides the
    exception's reason: integer or floating point division by zero, overflow,
    underflow, invalid operation, result out of range), this will not be possible
    because of the reasons mentioned.


  %     -+*|[ LOCAL SIGNAL HANDLING ]|*+-

  \subsection{Local signal handling} \label{Local signal handling}
   Signals are sent and received from tasks, not threads. This is correct
   according to the POSIX standard but will be enhanced to a thread-based
   signal handling, when the \texttt{pthread}-part of dietlibc is being ported
   to DROPS.

   However blocking and unblocking signals is already performed on a per-thread
   basis. The reason for that is the following: A task using L4Env consists of
   at most one main thread and several additional L4Env threads managing
   memory regions, semaphores and signals. To make sure that these L4Env
   threads are not used as executors for signal handling routines, we will
   have to block all signals for these threads while all other threads will
   per default not block any signals.

   Ignoring this problem and letting the L4Env threads execute signal handlers
   could raise a lot of problems because for instance the semaphore thread while
   executing a handler could not manage semaphores and thus a call to any of
   the \texttt{l4semaphore\_}-routines from the signal handler would result in a deadlock.

   By linking against the L4sig backend a signal handler
   thread is automatically added to each application. The signal handler
   thread first registers itself at the signal server and initializes
   local signal handling:

   \begin{itemize}
    \item
     user threads are set to not block any signals,
    \item
     L4Env threads are set to block all signals,
    \item
     signal handlers are set to SIG\_DFL,
    \item
     the signal server is looked up using \texttt{names\_query\_name()}, and
    \item
     the signal handler thread is registered at the signal server.

   \end{itemize}
   After initialization, the signal handler thread enters its service loop and
   requests a signal from the signal server via IPC. It is blocked within
   this IPC until a signal is available. The signal server eventually answers this
   IPC. After receiving a signal, the handler calls \texttt{dispatch\_signal()} to
   determine the executor thread of the signal handler and then uses the
   \texttt{thread\_ex\_regs()} system call to force the executor thread into the signal
   handling routine. After a handshake described next, the dispatch-routine
   returns and the signal handler thread is ready to receive the next signal
   from the signal server.

   If no executor thread may be found (e.\,g., because all threads are blocking
   this signal), the signal is marked pending and will be delivered, whenever
   a thread chooses to unblock this signal.

   After the executor thread has been forced into the \texttt{signal\_handling()}
   function, it first of all has to store the current register state as we
   need it later to return to normal work. After this, handshaking with the
   signal handler thread has to be done. The signal handling thread receives
   the executor's stack and instruction pointer on return from \texttt{thread\_ex\_regs}.
   The executor himself needs these pointers to return to normal work later.
   Therefore, these two are handed over through a producer-consumer-solution.
   (See the \texttt{bazar} struct and its use in \texttt{dispatch\_signal()} and
   \texttt{signal\_handling()}).

   Now that handshaking has been finished, the executor thread checks whether
   the application has registered a signal handler function for the signal
   and calls this if necessary. Otherwise the function \\ 
   \texttt{default\_handling()}
   is called to perform default signal handling. This procedure is repeated
   until there are no more pending signals for the executor thread. Finally
   the previous thread state is restored by resetting registers, instruction
   pointer and stack pointer.


   %     -+*|[ SPECIAL SIGNAL HANDLING ]|*+-

   \subsubsection{Special signal handling} \label{Special signal handling}
    Three signals need special handling. These are:

    \begin{itemize}
     \item
      SIGKILL: The user must not set up a signal handler for SIGKILL as the
      application is killed without application cooperation.
     \item
      SIGSTOP: The user must not set up a signal handler for SIGSTOP, the
      application is stopped until SIGCONT.
     \item
      SIGCONT: The application is continued after SIGSTOP.

    \end{itemize}
    SIGKILL handling starts within the signal server. A SIGKILL
    will only be delivered to the application when the application cannot be
    killed via RMGR or a task server. The signal handler thread then shuts
    down all worker threads, unregisters itself at the signal server and
    exits. Within L4sig there is the function \texttt{shutdown\_app()}, that
    cares about program termination.

    SIGSTOP causes the application to stop. A first solution was to set all
    non-L4Env threads to zero priority. As the system's idle thread is always
    scheduled before
    all other threads the stopped threads would never get to run again.
    Fiasco's priority donation mechanism causes a problem however: An evil
    application could now send an IPC to a zero priority thread and this thread
    would be raised to the sender's priority. To prevent stopped threads from
    running this way, it is necessary to \texttt{thread\_ex\_regs} them into the \texttt{\_\_sleep()}
    function where they will not be able to run their original code.
    The internal routine \texttt{stop\_app()} takes care of SIGSTOP handling.

    SIGCONT resets all stopped threads to their original stack and instruction
    pointers. This is internally done by \texttt{continue\_app()} in \texttt{default\_handling.c}.


 %     -+*|[ OPEN ISSUES AND KNOWN PROBLEMS ]|*+-

 \section{Open issues and known problems} \label{Open issues and known problems}

  There are a number of open issues to the signal server, which I am going to
  describe in the following section.


  %     -+*|[ IPC-ABORTION ]|*+-

  \subsection{IPC-Abortion} \label{IPCAbortion}

   If a signal is deliverd to a task, the task's signal handler thread
   chooses an executor thread and forces it into the signal handling
   routine by using \texttt{thread\_ex\_regs()}. Ongoing IPC is cancelled when
   the application calls
   \texttt{thread\_ex\_regs()} and it is not possible to determine the IPC's
   state. Therefore it is not possible to handle this abortion
   correctly.

   There are two possible solutions to cope with this problem. On the one
   hand the application programmer could lock every IPC in some way so that
   no signals are delivered when IPC is being done. Unfortunately all
   applications had to be adapted to use locked IPC for that.

   An example of such a locked IPC is shown below. The application sets
   all signals to be blocked, carries out IPC and then restores the old blocked
   signals.
  
   \begin{footnotesize}
   \begin{verbatim}
    sigset_t blocking, stored;
    // fill the sigset
    sigfillset( &blocking );
    // block all signals, store old sigset in stored
    sigprocmask( SIG_SETMASK, &blocking, &stored );
    /*
     * Your IPC here
     */
    // restore old sigset
    sigprocmask( SIG_SETMASK, &stored, NULL );
   \end{verbatim}
   \end{footnotesize}

   Another possible solution is to perform IPC as transactions. This needs to
   be supported by all IPC interfaces and would lead to speed losses, but 
   client and server could then undo aborted IPC operations and redo them at 
   a later time. 

   A feasible solution comes with L4v4, where we will be able to specify whether 
   an IPC shall be aborted. With this version out, it will be possible to reimplement 
   \texttt{dispatch\_signals()} without the problem of IPC abortion on 
   \texttt{thread\_ex\_regs()}.

  %     -+*|[ TIMED WAITING FOR SIGNALS ]|*+-

  \subsection{Timed waiting for signals} \label{Timed waiting for signals}
   POSIX defines \texttt{sigtimedwait()} to determine a signal set and a timeout
   to wait for any of the specified signals. This is not yet implemented
   by L4sig, but might be implemented in a way similiar to the alarm handling
   approach.


  %     -+*|[ MISSING SIGNAL GENERATION WITHIN USERLAND ]|*+-

  \subsection{Missing signal generation within userland} \label{Missing signal generation within userland}
   DROPS applications currently may not assume to always receive all
   signals as on Linux/UNIX machines. This is caused by a lack of signal
   generation allover the DROPS components.

   Examples:
   \begin{itemize}
    \item
     DOpE or the L4vfs term\_server could work with SIGWINCH to
     determine changes in terminal sizes
    \item
     the L4vfs term\_server should generate SIGTTIN and SIGTTOU

   \end{itemize}

  %     -+*|[ SECURITY PROBLEMS ]|*+-

  \subsection{Security problems} \label{Security problems}

   As long as DROPS applications remain cooperative, the L4sig signal
   mechanism will work. An evil application programmer might however 
   kill the application's signal handling thread and thus

   \begin{itemize}
    \item
     ignore signals in the worst case ``spam'' the signal server
     with signals to himself which are nevermore collected by the application.
     Thus more and more memory would be used by the signal server
     until there is no more free memory and the server is not able
     to perform its tasks anymore. This problem can be solved by inventing
     quotas for the signal handler threads and the signal server would
     stop accepting signals when a task's quota is full.
    \item
     set up his own signal handler thread which could lead
     to an application ignoring SIGKILL (if it depends on the
     signal thread´s cooperation as described in Section \ref{Signal delivery}) 
     and SIGSTOP. This problem can currently not be avoided.

   \end{itemize}

 %     -+*|[ EVALUATION ]|*+-

 \section{Evaluation} \label{Evaluation}


  %     -+*|[ FEATURES ]|*+-

  \subsection{Features} \label{Features}
   Currently L4sig is able to carry out the most of the basic signal
   functionality defined by the POSIX standard. Correctly, it is possible to

   \begin{itemize}
    \item
     send and receive signals on a per task basis,
    \item
     install signal handlers with one or three arguments on a per task
     basis,
    \item
     block and unblock signals on a per thread basis,
    \item
     set up and receive SIGALRM alarm signals, and
    \item
     manipulate signal sets as needed.

   \end{itemize}
   However these are the features still missing:

   \begin{itemize}
    \item
     distinct signal handling for each thread as provided by the \texttt{pthread}
     library,
    \item
     \texttt{sigtimedwait()} to enable suspending a task / thread until
     one signal out of a specified set is sent within a certain
     period of time, and
    \item
     automatic safety of IPC with signals enabled.

   \end{itemize}

  %     -+*|[ ALTERNATIVES ]|*+-

  \subsection{Alternatives} \label{Alternatives}
   The signal implementation consists of 380 lines of code\footnote{measured with cccc}
   within the signal server (+ \textasciitilde{}900 LoC generated by DICE) and 650 lines 
   of code for the L4sig backend.

   Using the already available \texttt{inter\_task\_ex\_regs()} call could possibly enable
   a signal implementation without a local signal handler thread. However
   this would put more load on the signal server and make the server
   a single point of failure. On the other hand it would also relieve us
   from the security problems mentioned in Section \ref{Security problems}.

   Advantage of a local signal handler thread is mostly speed because
   calls to set signal handlers and block/unblock signals are library
   calls manipulating task-global data structures. Without a local
   signal handler these data had to be stored within the signal server
   and each signal handling routine had to be mapped to IPC. This would
   slow down the signal implementation.


 %     -+*|[ CONCLUSION ]|*+-

 \section{Conclusion} \label{Conclusion}
  This document described the internals of a signal implementation
  for the DROPS operating system. Goal of the implementation was to
  provide a signal implementation on top of L4 with as much features
  requested by the POSIX standard as possible.

  Result of my work is L4sig, a signal backend for dietlibc providing
  basic signal functionality (blocking signals, registering signal
  handlers, sending and receiving signals). L4sig is supported by
  a signal server taking care of global data management.

  Lack of a \texttt{pthread} implementation and problems in the L4 interface
  caused restrictions which lead to an implemenatation, that is not
  entirely complete at the moment. Further improvements and enhancements
  will be made. Focus hereby will lie on the following issues:

  \begin{itemize}
   \item
    porting \texttt{libpthread} to DROPS, enabling thread-based signal handling,
   \item
    implementation of missing \texttt{sigtimedwait()} feature, and
   \item
    embed L4sig into DROPS, enable DROPS components to generate and
    handle signals.

  \end{itemize}
  If you have any problems, questions or remarks, please contact me.

  \newpage
  \appendix
 %     -+*|[ HOW DO I...? ]|*+-

 \section{How do I...?} \label{How do I}


  %     -+*|[ ... USE SIGNALS ON DROPS? ]|*+-

  \subsection{... use signals on DROPS?} \label{ use signals on DROPS}

   \begin{enumerate}
    \item
     Simply link your application against the following libaries:
     \begin{itemize}
      \item
       \texttt{libdiet\_be\_signal.o} for signal handling thread support
      \item
       \texttt{libsignal} for signal server support

     \end{itemize}
    \item
     Include \texttt{l4/libc\_backends\_l4env/l4signal.h} to use 
     the signal functions defined within dietlibc's
     \texttt{signal.h} \textbf{and} the \texttt{l4signal\_init\_idt()} function call to
     set up your threads for kernel signals.

    \item
     Run the \texttt{signal\_server} along with your applications.

   \end{enumerate}

  %     -+*|[ ... CREATE SIGNALS FROM MY APPLICATIONS? ]|*+-

  \subsection{... create signals from my applications?} \label{ create signals from my applications}
   2 ways:

   \begin{enumerate}
    \item
     You may use the \texttt{kill()} and \texttt{raise()} functions to generate
     custom signals including no more information than a signal
     number.

    \item
     For signals sending more information than just a number,
     please use the \texttt{l4signal\_kill\_long()}-call. For this you need
     to provide a correctly filled \texttt{siginfo\_t} field. For details
     on what to put in there, see the \texttt{dietlibc/include/signal.h}.

   \end{enumerate}

  %     -+*|[ ... MAKE SIGNAL_SERVER AND THE SIGNAL BACKEND COMPILE? ]|*+-

  \subsection{... make signal\_server and the signal backend compile?} \label{ make signalserver and the signal backend compile}

   Please make sure you have the latest versions of these packages:

   \begin{itemize}
    \item
     dietlibc
    \item
     libc\_backends\_l4env which includes L4sig
    \item
     signal which is the signal server package

   \end{itemize}

 %     -+*|[ RESSOURCES ]|*+-

 \section{Ressources} \label{Ressources}

  Most information on POSIX signals may be found within the
  according manpages. Especially interesting for you might be

  \begin{itemize}
   \item
    \texttt{man 7 signal} - a list of all signals
   \item
    \texttt{man 2 signal} - documentation of one argument signal handlers
   \item
    \texttt{man 2 sigaction} - documentation of sigaction, siginfo and
    three argument signal handlers
   \item
    \texttt{man 2 alarm} - documentation on alarms (SIGALRM)
   \item
    \texttt{man 3 sigsetops} - documentation on manipulating signal sets,
    that are used for blocking signals

  \end{itemize}
  Information on CPU exceptions may be found in
  \begin{itemize}
   \item
    IA32 Intel Architecture Software Developer´s Manual - Basic Architecture
   \item
    IA32 Intel Architecture Software Developer´s Manual - Instruction Set Reference 1 \& 2
   \item
    IA32 Intel Architecture Software Developer´s Manual - System Programming Guide

  \end{itemize}

 %     -+*|[ CODE STRUCTURE ]|*+-

 \section{Code structure} \label{Code structure}

  This chapter will give a short overview of dietlibc backend for signal
  handling. The files are listed and described in their logical order.

  \begin{enumerate}
   \item
    Signal setup
    \begin{itemize}
     \item
      \texttt{startup.c} - includes the signal handling thread and a constructor function
      which sets up this thread for each application.
    \end{itemize}
   \item
    POSIX library calls
    \begin{itemize}
     \item
      \texttt{signal.c} - implements the \texttt{signal()} library call to set up signal handling
     \item
      \texttt{sigaction.c} - implements the \texttt{sigaction()} library call to set up signal
      handling
     \item
      \texttt{procmask.c} - implements the \texttt{sigprocmask()} routine to block and unblock
      signals and the \texttt{sigpending()} function to determine pending signals
     \item
      \texttt{alarm.c} - implements the \texttt{alarm()} routine to schedule a SIGALRM
    \end{itemize}
   \item
    Internal routines
    \begin{itemize}
     \item
      \texttt{dispatch.c} - implements the \texttt{dispatch()} function which determines the
      thread which will handle a signal and some helper functions to determine
      the first thread alive \\
      (\texttt{find\_thread\_alive()}) and the first thread not
      blocking a specific signal \\ 
      (\texttt{find\_thread\_for\_signal()})
     \item
      \texttt{default\_handling.c} - implements default signal handling (\texttt{default\_handling()})
      and helper functions to handle SIGSTOP and SIGKILL (\texttt{shutdown\_app()},
      \texttt{stop\_app()}, \texttt{continue\_app()})
     \item
      \texttt{enqueue.c} - implements local signal management
    \end{itemize}
  \end{enumerate}
\newpage
\bibliographystyle{plain}
\bibliography{custom,master}
\end{document}
