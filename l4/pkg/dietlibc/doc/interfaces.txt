open issues:
 - For Linux file descriptors there is no distinction between files and
   directories at interface level. Therefore it is possible to use
   readdir on a file descriptor containing a regular file. At runtime
   this will result in error ENOTDIR.
   Given that situation it doesn't make sense to model the Linux files
   using different interfaces.
 - However, it is possible to break down the many Posix functions into
   groups of functions with special concerns (access right
   administration, creation of objects, accessing objects, ...).
 - Some Posix functions can not be easily sorted to a specific group
   as they accomplish several task: creat(), for example creates a
   file, positions it in the names space, so that other processes can
   access it right afterwards and open it, returning a file
   handle. The positioning in the names space has the side effect of
   modifying the parent directory.
 - For the network functions these two functions are separated (socket
   and bind) as it is often not necessary to position an object in a
   name space (client side).
 - Something similar can be seen with temp files, which are created,
   and thereby opened, and directly unlinked afterwards, which removes
   them from their parent directory and therewith from the
   namespace. The creating process itself can refer to the file as
   long as it keeps a file handle to it open. So, in essence the used
   operations are: create, insert to name space, remove from
   namespace; just because the first two operations are coupled
   together.

 - The distinction between object names and object identity is
   important. We need a concept somewhat similar to inodes / uuids.
 - Questions: Shall the `current working directory` be bound to a
   path-name, or rather to the id of the directory?  For the second
   case it would be necessary to be able to translate the ids to
   actual path names.
    - In Linux:
        * shell1: moves to /tmp/mp26/test1
        * shell1: pwd -> /tmp/mp26/test1
        * shell2: mv /tmp/mp26/test1 /tmp/mp26/test2
        * shell1: pwd -> /tmp/mp26/test1
        * shell2: lsof | grep "/tmp/mp26/" -> shell1: /tmp/mp26/temp2/test1
        * shell1: cd .
        * shell1: pwd -> /tmp/mp26/test2/test1
    -> so, in Linux the `cwd` is bound to the inode

 - If we want to keep the semantics in this case, we will have to use
   similar concepts.
   So, each file-system server need the following functions:
    - generate uuid for given name (if valid)
    - find name for given uuid
    - the uuid should be unique, also in time!
    - the uuid for a given (path) name should be valid for a long time
      - for persistent file systems: forever? (as long as the
        directory exist)
      - for dynamical filesystems (like proc): maybe for livetime of
        the server?
