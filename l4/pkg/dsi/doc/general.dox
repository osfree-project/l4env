/*!\file doc/general.dox
 *
 * \brief Mainpage definition and some concept description.
 */


/*!\mainpage DSI - Drops Streaming Interface Documentation

\ref p_doc

\ref p_intro

\ref p_rt

\ref p_mem

\ref p_sync

\ref p_setup


\ref p_api

*/
// x \htmlonly <a href="modules.html"> Module </a> \endhtmlonly y


/*! \page p_doc About this documentation

This documentation was created using Doxygen, a source-code documentation
system.

Documentation of functions, structures and defines is done in the
source code. Documentation of concepts is done in separate files. To
get an overview of the general concepts, browse through the pages
referenced by the <a href=http:index.html> main page</a>. These pages
will contain links to documented source-files describing things in
more detail.

A documented source-file contains a comment about what the file is dealing
with. In some cases, a more detailed description of the file is available.
File members are listed then together with their desrciption. A formated
version of the source-files itself is also available via links within
these documented source-files.

The concept pages together with this page are generated from the file
general.dox. Source-file documentation is generated from c-files in
\a lib/src and from some header files in \a include/drops/dsi.


\risks
-# This specification may change frequently next time, when the
   first experiences using DSI are made.
-# DSI depends on the L4 environment, which is neighter completely specified
   nor completely implemented yet.

\todo The generated postscript-file is hard to read at the moment. Create
      a framing .tex document and include the files generated by doxygen.

\author		Jork Loeser
\reviewer	Frank Mehnert, Lars Reuther
\witness	Lars Reuther
\date		20/02/2001
\version	0.4
*/


/*!\page p_intro Introduction and Definitions of Terms

DSI defines an interface for communication between DROPS-components. The main
aspects of the interface are

- packet-oriented zero-copy data transport between all parties
- traffic description based on jitter-constrained periodic streams
- QoS-support with nonblocking synchronisation and limiting the
  validity of data by time
- isolating the communication partners with respect to CPU and memory usage at
  the communication channel
- support for packet dropping and resynchronization
- blocking synchronisation for non-realtime components
- active data transport, independent of the initiating client application

The usual application scenario includes a sender and a receiver with a
connection in between. Because the sender and the receiver often are
servers in the DROPS environment, the connection is usualy being setup
by the common client of both servers.

DSI defines a \a component as an active part, which is either the
sender or the receiver. The communication endpoint in a component is
called a \a socket. To operate on sockets, the 
\ref g_component "DSI API for components" is used.

Contrary to components, an \a application creates a connection and
initiates the data transfer but is not involved in the actual data
transport.  The connection created by the application is referred to
as a \a stream, the term is only valid in application context.

An application uses component-specific interfaces to trigger the
creation of a send- and a receive-socket at the components. Both
components return references to their sockets called \a socket \a
references. Then the application uses the
\ref g_app "DSI API for client applications" to create and
operate on the stream.

\image latex arch.eps	Architectural Overview
\image html  arch.png	Architectural Overview


\subsection sec_prerequisites Prerequisites

DSI needs an L4-compatible mikrokernel and the L4 Environment to run.


*/



/*!\page p_rt Realtime Communication


To allow realtime components to communicate, DSI defines requirements
to the components and an interface that helps components to check for
conformity of their peers. This section describes what DSI requires
and provides with respect to realtime communication. In this section
we assume to have realtime-components unless otherwise stated.

On connection setup, the traffic description of the intended
connection is specified. This description is mainly a
JCS-specification. It will be used to calculate buffer space and start
offset of the connection to be created. Both the sender and the
receiver must specify the same traffic description.

During data transfer, both components are responsible for meeting
their traffic specification made on connection setup. This includes
the bandwidth, the jitter and the packet rate. Obviously the
components need a common time base, which is supported by DSI. It is
left to the components to ascertain which data is valid according to
the given time and the traffic specification of the connection.

\todo Support a common timebase by DSI. This includes the definition
      of a basic unit, a variable/function to get the time, functions
      to calculate the current/first/last packet and functions to tell
      if a packet is not yet/not any longer available.

If one components wants to compromise the other, the DSI API and its
implementation behind cannot help to enforce metting the traffic
description. However, the API supports the components in checking if
the peer is well-behaving.

Following situations can happen:

-# A send component, like a file provider, offers data at a certain
   bandwidth. The receiver consumes the data with a lower
   rate. It is not a fault of the receiver, it is the intended
   behaviour. The correct scenario might be to send in blocking mode,
   and to receive in nonblocking mode. If the receiver consumes data
   too fast, or the sender is too slow, the receiver will realize this
   when trying to get data.
-# A send component, like a framegrabber driver, delivers data with a
   certain bandwidth. It cannot stop its dataflow. The receiver, e.g.
   a compressor, takes the data and converts it. The conversion
   process is non-interruptible, this may be the case with imported
   code from another project. If the receiver consumes the data slower
   than the sender sends, data will be overwritten after a certain
   time. At a result the data the receiver is currently working on
   gets corrupted. The solution DSI offers is to check a sequence
   number assigned to the data prior and after accessing it. If it
   turns out that the sender has overwritten the data while the
   receiver was operating on it, the computed result must be
   discarded. This optimistic approach requires the receiver to not
   getting confused by corrupted input data. But this is required
   anyway, if the sender is not trusted.
-# Assume the same situation like above, but now the receiver is
   interuptible or can at least handle a signal. DSI allows to
   register a callback that is started if the sender reclaims data
   that is not acknowledged by the receiver.
-# The send component, like a network device, delivers data with a
   certain bandwidth. The receiver is to slow, but does not want the
   sender to reclaim data the receiver did not acknowledge. DSI allows
   the sender to realize that the data is not acknowledged, so in turn
   it can discard the new data.

\todo Reclaiming data is currently not implemented. Implement it
      together with the according callback.



*/


/*!\page p_mem Data Transfer

Data is transfered using a shared memory area between the sender and
the receiver. DROPS memory regions are used to administrate this
memory. In most cases the shared memory region is created on \ref
p_setup "connection setup" and exists until the connection is
closed. In some cases it is necessary to use dynamic mapping to
transfer the data. See the \ref sec_mem_discussion. The memory
backing the shared region can be of any type. This includes normal
on-board memory, but also memory on adapter cards like a video card or
a framegrabber. This allows a component to offer data from hardware
devices without copying it in a transparent way to the clients of this
component. This works also for the receiving direction, if the sender
of the data respects the layout the receiving hardware device may
impose.

Once the shared memory is established, it is in the responsibility of
the sender to choose appropriate pieces of this region for data
transmission. The sender selects a piece in the shared memory, stores
the data in it and uses the DSI API to communicate the location of the
data to the receiver.

DSI uses packets containing a scatter/gather-list to refer to the data
in the shared memory. There are no restrictions on the size and
alignment of the scatter/gather-elements by DSI. But hardware
components may add these restrictions, and the corresponding
components must signal this separately to the communication
peers. Currently, DSI does not support this signalling of alignment or
size restrictions.

The references to data in the scatter/gather-lists are stored relative
to the beginning to the data region. This way the shared data region can
be mapped at different addresses into the senders and the receivers
address space.

\todo Add signalling of alignment and size restrictions to DSI.


\subsection sec_mem_api DSI Memory Interface

To get the address and size of the shared memory region (or the region
intended for data transfer in the case of dynamic mapping) use
dsi_socket_get_data_area().  To add a piece of memory to the
scatter/gather-list of a packet use dsi_packet_add_data(). The
receiver uses dsi_packet_get_data() to get the data fragments from the
scatter/gather-list.

Information about getting and sending packets can be found in the \ref
p_sync "Synchronisation section".


\subsection sec_mem_discussion Discussion on the Pros and Cons of Dynamic Mapping

The following discussion presents the pros and cons of dynamic mapping
as a technique to enforce correct synchronisation in nonblocking mode.

In nonblocking mode, there are no IPCs used as synchronisation points,
the components must synchronise using timers and variables. One
suggestion was to use dynamic mapping and unmapping in the data region
to enforce correct synchronisation. The idea behind is, that the
sender component builds a window of valid data by mapping only the
parts, that it likes to be accessible at that time. If the receiver
tries to access data which is out of this window, it would receive a
signal generated by a pagefault-ipc. The advantage of this proposal is
the implicit signalling mechanism, not disturbing in normal operation.

A problem of the solution is that it does not ensure to detect
malfunction. The memory region is limited in size, a wraparound is
needed. If the difference between sender and receiver is large enough,
it wont be detected. This means, other synchronisation mechanisms are
still needed, nothinging the advantage of easy signalling.

The overhead of the mapping ipcs related to every chunk of data is a
real downside. Every data transport will require a mapping IPC
together with a relatively costly unmapping syscall.

An want-to-be argument is that the sender can manage its ressources
more flexible with this architecture. It is weak for the following
reasons: The ammount of memory the sender needs is precalculated by
jitter and bandwidth and does not change. So the sender has no reason
to reclaim memory during operation to lower the amount of memory for
the connection. If a sender wants to exchange the physical pages in
the memory region, dynamic mapping is needed. But this can be done
without producing holes in the shared area and has nothing to do with
synchronisation.

To sum it up, the dynamic mapping as the principal technique for
signalling has no advantages, but introduces some overhead. Thatswhy
it is not used in DSI. Mapping of particular pages offers additional
functionality for shuffling physical pages at the sender and is
therefore included in DSI.

*/



/*!\page p_sync Signalling and Synchronisation Issues

To signal data committed by the sender DSI uses packets that are
enqueued in a ringbuffer at the \a control \a region. The
control region is a shared DROPS memory region which is
established at \ref p_setup "socket setup". The sender asks for a free
packet, fills in its data and commits the packet. The receiver gets
the packet from the control region, reads the data out of the
packet and acknowledges the packet. A packet is called \a allocated
after the sender requested it, it is called \a filled after the sender
commited it. Otherwise a packet is considered as \a free.

Synchronisation happens when getting a packet, commiting it or
acknowledging a packet. It can be done asynchronously or
synchronously. The send- and receive-components are not related in
their synchronouity, one can work synchronous, the other one can work
asynchronous. It can even be different for each packet.

\subsection sec_sync Synchronous mode and Semaphores

In synchronous mode, the receiver is delayed on getting a packet until
a packet is commited by the sender. In the case of a full control region
the sender is delayed on getting a free packet until the receiver
acknowledged an old packet.

To do so, DSI uses counting semaphores. The current implementation
features one semaphore per packet, two semaphores counting the free
and allocated packets would be another possibility.

If a semaphore-counter at component \c A becomes -1 on decrement, the
semaphore-imeplementation requests a free-IPC from component \c B at
the other side of the connection. This is done by making an IPC-call
with infitite timeout to a synchronisation thread running with \c
B. If \c B realizes the blocking situation on an up-operation afterwards,
it tells its synchronisation thread to answer the IPC-call with a free-IPC
with timeout 0 back to \c A. The blocking situation is noticed
atomically on the up-operation by \c B. In the case \c B notices the
blocking situation before \c A did the IPC-call, the synchronisation thread
waits for the IPC from \c A before sending its own free-IPC. This way
it is ensured that the communication is working even on mutual
untrusting components. All receive-IPCs are closed receives, and not
sending an IPC only harms the component itself but not the peer.

\image latex sig_sync_ex.eps	Communication on blocking semaphores
\image html  sig_sync_ex.png	Communication on blocking semaphores


The downside of this implementation is that each connection requires
one additional thread at both components. Another drawback is the
additional IPC at \c B to the synchronisation thread, which could be
ommited by extending the L4 interface with a 'send-as IPC' or a
'send-to-A receive-from-B IPC'.


\subsection sec_async Asynchronous mode

In asynchronous mode, the receiver makes assumptions on the
availability of new data based on a timebase and checks if this is the
case. The sender works similar, it checks if there is free space in
the control region for a new packet and possibly discards the data.

The asynchronous mode allows a sender to proceed with its work,
independent of an potentially untrusted client. If the receiver does not
acknowledge the data (and thus free the packet in the control
region), it only hurts itself.

There a two different ways to handle a full control region resulting of
unacknowledged data. One possibility is to discard the new data at the
sender and not to withdraw the old packets. This means, if a receiver
does not acknowledge old packets fast enought, it will miss new
packets. This has the advantage, that a receiver can rely on the
validity of a packet until it acknowleded it. But the data may be
destroyed in between, think of a framegrabber card. The sender can
mark this in the corresponding packet descriptor, so that the receiver
is able to realize this. The other advantage of this approach is that
packets are stored in-order in the control region. The tracking of the
current packets is easy this way. This is the current implementation.

The other possibility is to overwrite old packets at the sender in the
case of a full control region. This requires the receiver to check the
validity of the data prior and after dealing with a packet. The
advantage of this mode of operation is that a receiver can simply
ignore a couple of packets if it is to slow. It always has the newest
data available, the receiver does not need to acknowledge the old data
to get the new one. This mode is currently not implemented. To support
this mode, the DSI-API must provide the following functionality: The
sender and the receiver must be able to specify a specific packet they
want to get, even if it is out of order. DSI must allow to get a
packet even if it is not free. DSI should provide functions to check
if packets are valid/free and it should provide callbacks that are
called if a packet is reclaimed.


\subsection sec_sync_api DSI packet interface

To get a new packet in the control region use the dsi_packet_get()
function. This works for sender and receiver aswell. The sender
commits a packet after filling it with data with the
dsi_packet_commit() function. Currently, the receiver uses the same
function to free a packet after getting the data out of it. This may
change to dsi_packet_acknowledge() in the future. For getting data in
and out of a packet see the \ref p_mem "Data Transfer section".


\subsection sec_sync_discussion Discussion on Component-local Signalling between Worker Thread and Synchronisation Thread in Blocking Mode

This section deals with the consequences of the problem, that the
synchronisation threads should only do a closed receive to prevent DoS
attacks. The current implementation uses an open receive at the
synchronisation thread.

The following discussion assumes two components, component \a L and
component \a R, with \a L beeing blocked on \a R, because of waiting for
signalling of packet N. The synchronisation thread of \a L is S, the
worker thread of \a L is L and the worker thread of \a R is R.

\image latex sig_discussion.eps	Local signalling
\image html  sig_discussion.png	Local signalling


\a L must be aware of \a R to be potentially misbehaving. An attack of
\a R is allowed to influence S but not L. \a R must rely on \a L: if
\a R decided to wait anyway, it will tolerate silence of \a L, and
wrong signaling by \a L is equivalent to sending wrong data or
discarding data (depending on the direction of data flow). As a
reminder, packets can be signalled in any order in the synchronisation
region.

The closed receive requires S to wait on R, and only if the
corresponding packet is not already signalled (which can be happened
in between), S will wait for L then. Because L must not be blocked by
misbehaving R, S must flag that it will wait for L. Signalling of N
happens in a shared region with \a R, so \a L can be spoofed on
this. To ensure L and S to have the same idea of the signalling and
flagging state, L and S must use a private synchronisation mechanism.
The easy solution is a blocking semaphore implementation, but there are
faster ways.

We assume a maximum of \a p packets to be stored in the
synchronisation region.  A solution would be to have \a p fields
containing an entry with the signalled packet and another entry with
the IPC flag, both accessible by one atomic operation. S could
atomically test the state and optionally set the flag. This downside
of this solution is the additional field.

Another algorithm uses two variables, \a interest, and \a
ipc. \a interest and \a ipc are placed in a way that they can be
inspected and modified atomically. The worker thread L does the
following steps:

-# signal(N)
-# atomically: if(\a interest == N) \a ipc = N
-# if(\a ipc == N) send_ipc_to(S)

The synchronisation thread S does the following steps:

-# \a interest = N
-# if(not signalled(N)) \a ipc = N
-# \a interest = 0
-# if(\a ipc == N) rcv_ipc_from(L)

This algorithm works under the precondition that N is unique, this
means, both the worker and the synchronisation thread do not execute
this algorithm with the same N twice. While this can required for the
work thread, the synchronisation thread must obtain it's N from the
remote thread R, thus can be spoofed. A solution to this problem could
be to reset \a ipc in a suitable way, e.g. by doing a long-ipc between
L and S which atomically resets \a ipc to 0. The downside is the long-ipc.

The last algorithm tries to reset the ipc-variable in a safe
way. Unfortunately, it is complicated and not proofed for correctness.
The algorithm uses the four variables \a s_w, \a s_s, \a interest, and
\a ipc. \a interest and \a ack are placed in a way that they can be
inspected and modified atomically. The worker thread L does the
following steps:

-# N == \a s_w ? Error
-# signal(N)
-# atomically: if(\a interest == N) \a ipc = N
-# if(\a ipc == N) {
-#    \a s_w = N
-#    send_ipc_to(S)
-#    if ( \a ipc == N) ipc = 0
-# }

The synchronisation thread S does the following steps:

-# N == \a s_s ? Error
-# \a interest = N
-# if(not signalled(N)) \a ipc = N
-# \a interest = 0
-# if(\a ipc == N) {
-#    \a s_s = N
-#    rcv_ipc_from(L)
-#    if(\a ipc == N) ipc = 0
-# }

After that, the synchronisation thread S can safely send the unblocking
IPC back to R (with timeout 0, of course).

*/


/*!\page p_setup Connection Setup

To setup an DSI stream, a send-socket and a receive-socket must be
created, which is done at the involved components. Then the sockets
must be connected by the application. Both components
can reside in separate address spaces, but it is also possible for
one or even two of them to be in the applications address space.

See the following sections describing
- \ref sec_setup_application
- \ref sec_setup_component
- \ref sec_setup_api

\todo Write about starting the communication, delaying the receiver.
      We must define how signalling of prework-time at sender-side
      works.


\subsection sec_setup_application Connection Setup at the Application

Normally, the application uses component-specific functions to
initiate a connection. These specific functions send
socket-create-requests with suited parameters to both sender and
receiver components, which are typically unrelated servers. These
parameters usually contain a traffic description that can be converted
to a jcp-description by the components. In reply to the requests the
application gets two DSI component references, one for the sender
and one for the receiver. The references allow DSI to locate the
components and address the sockets. Function-pointers in the
reference allow component-specific connect-, start- and stop-code
to be executed. The application creates the stream by passing these
references to the dsi_stream_create() function. The created stream
can be started, stopped and destroyed using the common DSI interface.

For example, a fileserver could provide an open-function to open a
file in read mode having a filename and a bandwidth as arguments. This
open-function sends an open-request to the fileserver and returns a
component reference together with two memory regions. The component
references points to the fileserver and the created socket, and
contains the functions to send connect-, start- and stop-messages
to the server. The memory regions are passed to the open-function of a
server receiving data and will be used for data transfer and
synchronisation. The application never deals with buffer size
calculation or memory allocation, this is done at the components or
its support functions. This
fileserver example makes clear why it is out of the scope of DSI to
support a socket create function suitable for all possible
components. It is more flexible to use specific functions in a first
step for connection setup and to switch to a common interface in a
second step.


\subsection sec_setup_component Connection Setup at the Component

In reaction to receiving a component-specific open-request the
component creates a local socket. This requires a data region for
storing the data to transmit and a control region for the
communication with the peer. Further a work thread that will call the
DSI signalling functions and a synchronisation thread are needed for
the socket. For details on data transfer see \ref p_mem, for details
on signalling see \ref p_sync.

Both the data region and the control region will be shared between the two
sockets of a stream. While control regions are always exclusive for
one stream, it is possible for data regions to be shared between
multiple streams. DSI can allocate both regions automatically on socket
creation. Alternatively, a component can create the data region by
itself, which is necessary to use the memory on an adapter card
instead of onboard main memory. A stream description contains
information to calculate the minimum sizes of the data and control
regions and the space to be reserved for the scatter-gather lists. It
should be calculated from the parameters of the component-specific
open function and is always needed for socket creation. It is obvious that
the same memory regions used at the first component must be passed to the
other component of the stream. Even if unusual, it is possible to
create both data region and control region at the application and pass
them to the components. On socket deletion, DSI will free
automatically allocated regions by itself, but not the regions that were
created previously to socket creation.

Synchronisation threads are used exclusively by one socket, so each
stream will result in at least two new threads. These threads will
be allocated automatically with automatic removal on socket
deletion.  The work thread is the only thread that will be able to get
and commit packets for the socket. It can be shared with other
activities and sockets. Automatic creation and deletion is provided
for the work thread too.

\todo Write somewhere about the callbacks.

\todo Write about the flags on socket creation.


\subsection sec_setup_api DSI Connection Setup Interface

To reference to a socket at a component, applications use the
structure #dsi_component_t. Applications create a stream with
dsi_stream_create(), start a stream with dsi_stream_start(), stop it
with dsi_stream_stop() and delete it with dsi_stream_delete().

To convert a jitter-constrained periodic stream to a
stream-description, use dsi_jcp_2_config(). Components create a socket
with dsi_socket_create(). A reference to the local socket can be
obtained with dsi_socket_get_ref(). Together with function-pointers
for specific message handling this reference forms a component
reference. A local socket is connected with a socket reference to a
remote socket using dsi_socket_connect(). To retrieve an opened socket
from the numerical socket ID of a socket reference, use
dsi_socket_get_descriptor(). To set the callback function that is
called on every blocking-related IPC, use
dsi_socket_set_sync_callback(). The sender can specify a callback
function for acknowledge-events at the client using
dsi_socket_set_release_callback(). A socket is closed with
dsi_socket_close().

*/

/*
A stream-description containing the maximum number of
packets to store in the packet-queue and the maximum length of the
scatter-gather lists is needed. DSI provides functions to map a
jitter-constrained periodic stream to these parameters. The socket
creation further requires a memory region and a control region where the
data and control information is stored. 

A component can create these
regions by itself, which is necessary to use the memory on an adapter
board instead of onboard main memory. 

Because the two regions are shared, the second component must specify
the regions used by the first one.  This means, the open-function must
pass this information somehow. Further arguments to create the socket
are the id's of the work-thread and the synchronisation thread. The
threads are described in the \ref p_sync "synchronisation
section". The synchronisation thread can be created automatically on
socket creation.

Flags are used to specify what kind of socket the component wants to
create, these flags also specify if the socket will operate in
blocking or nonblocking mode, and if the callback-functions on getting
and commiting a packet will be used.

*/



/*!\page p_api DSI API

The API consists of a lot of functions. They are seperated into groups to
ease the navigation.

-# \ref g_stream "the stream API" (dsi_stream_xxx)
-# \ref g_socket "the socket API" (dsi_socket_xxx)
-# \ref g_packet "the packet API" (dsi_socket_xxx)
-# \ref g_thread "the thread helpers" (dsi_thread_xxx)
-# \ref g_general "miscellaneous functions"

*/

