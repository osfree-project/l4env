/* $Id$*/
/*! \file generic_ts/idl/generic_ts.idl
 *
 * \date   06/04/2000
 * \author Frank Mehnert <fm3@os.inf.tu-dresden.de>
 *
 * \brief Generic task server interface
 */

module l4
{
  interface ts
    {
      struct taskid_t
	{
	  unsigned long low;
	  unsigned long high;
	};

      /** Allocate a new task id. Returns -L4_ENOTASK if no task is available.
       * We have to split allocating and creating the task in two steps 
       * because creating a task means that the task starts immediatly. If
       * the task starts before the task's pager doesn't know the task ID
       * of the new task, the pager gets confused and should deny the page
       * fault handling for that task. Therefore we allocate the task ID in
       * the first step and can tell the new task ID in the next step. Finally
       * we create the task. */
      long allocate(out taskid_t taskid);

      /** Create the task. The taskid must be owned by the client. */
      long create(inout taskid_t taskid,
		  in unsigned long entry, in unsigned long stack,
	          in unsigned long mcp, in taskid_t pager,
		  in long prio, in string resname, in unsigned long flags);

      /**
       * Free previously allocated task ID.
       *
       * \param taskid	ID of the task to free.
       * \return 0		 on success
       *         -L4_ENOTFOUND   if invalid task
       */
      long free(in taskid_t taskid);

      /** Terminate task. */
      long delete(in taskid_t taskid);

      /** terminate all tasks owned by caller */
      long delete_all();




      /** transmit right to create a task to the caller
       * E.g. L4Linux depends on it. */
      long get_task(in unsigned long taskno);

      /** transmit right to create a task back to the server */
      long free_task(in unsigned long taskno);
    };
};

