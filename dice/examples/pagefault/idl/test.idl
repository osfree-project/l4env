/*
 * A simple example to demantrate a pagefault handler
 *
 * Since a pagefault has only two dwords in its message, the
 * first the pagefault address and the second the instruction
 * pointer. SInce we usually use the first dword for the opcode
 * we have to build the server loop in such a way, that it will
 * accept its usually messages _and_ accept pagefaults. It has to
 * differentiate between a pagefault address and a valid opcode.
 *
 * In L4 version 2 we can do this by setting the opcodes with the
 * [uuid] attribute to a range, which will generate no pagefaults.
 * The opcodes are generated by shifting the interface's uuid
 * left by DICE_IID_BITS (default) and adding the function opcode.
 * If we want the opcodes to be kernel memory addresses, they have 
 * to start at 0xC000'0000. So we have to set the uuid of the interface
 * to 0xC00 (its shifted left 20 bits). Now we have opcodes, which can
 * be differentiated from pagefault addresses.
 *
 * We "only" have to tell the server loop what to do if it receives
 * an "invalid" opcode. This is done using the [default_function]
 * attribute. The function name specified with default_function is
 * called in the default branch of the server switch (hence the name).
 * It receives three parameters: the CORBA_Object, which is the sender
 * of the page_fault, the message buffer, and the CORBA_Environment.
 * The message buffer can be used to extract the pagefault_address
 * and the instruction pointer. See the pf_handler.c file for details
 * on that.
 */

[uuid(0xc00),default_function(pf_handler)]
interface handler
{
  /*
   * This is a simple function to check the status of the server
   */
  void check_status([out] long *status);
};

