\section{Message Buffer}
\label{sec:message-buffer}

This chapter explains the structuring of the message buffer.  It
evaluates the different approaches to message buffers.

\subsection{Array of Bytes}

There are characteristics of the message buffer, which have to be determined
by the IDL compiler: size and the elements it should contain.  The size is
determined by the size of its elements, that is, the sum of the element's
sizes.  The elements, which will be marshalled into the message buffer, are
mainly dependent on the directional attributes.

The size of an element (or parameter) is determined from the parameter's
size.  If the parameter is an array, the size of the type is multiplied by
the extend of the array.  The extend of the array can be fixed or variable.
Fixed sized arrays are determined by either an integer value in the array
bound or an integer value (or constant) in the \verb|[size_is]| attribute.

%% older...
The size depends on different variables.
One is the number of parameters and their size.  The size of a parameter is
usually determined by the type of the parameter.  If the parameter is an
array, the size of the type has to be multiplied with the number of elements
in the array.  If the array is variable sized, another variable is
important.  If the message buffer is at the client side and the array is
variable in size, so does the message buffer has to be.  An exception is the
usage of the \verb|[ref]| attribute, because then the parameter is transmitted
using indirect strings.

At the server side the message buffer has to be constant in size, so there
has to be an \verb|[max_is]| attribute to denote the maximum size of the
array, so the maximum size of the message buffer can be determined.

If, at the client side, the maximum size of the variable sized parameters
for one direction is smaller than the fixed size of the message buffer for
the other direction, the client side message buffer is fixed in size.
Variable sized parameters require besides the size of their elements an
additional word in the message buffer to store the size of the variable sized
array.  If there is a \verb|[size_is]| attribute containing a parameter of
the function, then it is stored in the message buffer and no additional word
is required.  If no maximum size for a variable sized parameter is given
\dice{} uses heuristics to determine the maximum size.  For instance, a
string is usually no longer than 512 bytes.

For L4 version 2 there are also special conditions for parameters.  All
parameterswith the \verb|[ref]| attribute are transmitted using indirect
strings.  Thus, even though they might be variable in size, the message buffer
is not, because a indirect string occupies a fixed number of bytes (two words)
in the message buffer.  At the receiver side memory has to be allocated for
this parameter to receive it.  To specify the size of memory to be received,
\dice{} has to determine all possible \verb|[ref]| parameters to be received
into one indirect string and the maximum of their \verb|[max_is]| values.

Flexpages always have to come first in the message buffer.  Their existence is
denoted by setting a bit in the address of the message buffer before
initiating the system call.  The kernel then interprets two words as a
flexpage until it reaches a zero flexpage, where the two words contain the
value zero.  An exception is a short flexpage IPC, where only the two short
IPC words are used for a flexpage.  No zero flexpage is required.  Flexpages
thus influence depending on different options.  If no other values are
transmitted with a single flexpage, the required space is two words and a
short IPC can be used. If there is an opcode or exception to be transmitted
with the flexpage, the message buffer must also contain the zero flexpage.

For L4 version X.0 this restriction is a little bit loosened.  Because the
kernel provides three words for short IPC, even an opcode can be transmitted
with a short flexpage IPC.  So if no other parameters beside the flexpage are
transmitted, a short flexpage IPC can be used, independently from the compiler
options. L4 version X.2 provides a maximum size for the message buffer: 64
words.  If this size is exceeded by the  parameters marshaled into the message
buffer, suitable parameters have to be transferred using indirect parts.
Because X.2 supports scatter/gather IPC, no special precautions have to be
taken for the receive buffer have to be taken.  It simply has to be big enough
to hold the maximum size of all indirect parts.  Single indirect parts can
then be referenced inside the receive buffer. L4 version X.2 also has a
different ordering for flexpages.  They come after the indirect parts and
therefore have to be sorted in the message buffer to the end.

\subsubsection{Initialization}
Initialization of the message buffer iterates over the functions of the
interface and calls methods to return the fixed size and the variable size of
its parameters.  $\rightarrow$ Maybe we should calculate this in the message
buffer. Thus, we do not distribute logic to determine when to use the correct
size across the back-end.  A method like
\verb|CBEMsgBufferType::GetParameterSize| seems appropriate.

\subsubsection{Parameter order}
Parameters are ordered according to the outlined rules.  A function does
contain a list of the parameters as they are defined in the IDL and a list
ofsorted parameters.  During marshaling the sorted list is iterated and each
element is marshaled or unmarshaled.

\subsubsection{Problems with the array buffer}

Most problems result from the usage of a byte array.  Modern compilers
optimize the assignment of elements of an array by reordering access
instructions.  This can lead to an aliasing problem:At position 4 a short
value (2 bytes) is marshaled, then at position 6 another short value.  After
the assignment a word value is read from position 4.  The compiler may
rearrange the steps, because it assumes that the two accesses to position 4
are dependent on each other, but access to position 6 is not.  It tries to
optimize cache  locality by placing the two accesses to position 4 right
behind each other.

\subsection{Unions}

The aliasing problem can be solved using unions and \verb|structs|.  At
client side a message buffer consists of a union of \verb|structs|: one for
the send direction (\verb|_in|), one for the receive direction
(\verb|_out|), and one containing the type of the message buffer
(\verb|_msg|) for the IPC.  The \verb|structs| each contain the parameters
inthe right order.  Marshaling is done using simple assignments of members
of the  \verb|struct| and the corresponding parameter. Arrays are
either transferred as indirect parts or an variable sized array is part of
the \verb|struct| (at the end of the \verb|struct|).  In the latter case,
the variable sized arrays have to be marshaled similarly to the algorithms
used for a message buffer consisting of an array of bytes.

At the server side, the message buffer is a union of all function's \verb|_in|
and \verb|out| \verb|structs|.  Thus unmarshalling means identifying the
correct struct and simply assigning members to parameters.

\subsubsection{Parameter order}
Because the message buffer's \verb|struct| is then the ordered sequence of
parameters, no extra list would be necessary in the function.  For L4 version
2 it is reasonable to place  two (or three for X.0) parameters of word size at
the beginning of the \verb|struct|.  Thus these parameters do not have to be
marshaled, but can directly be used with the IPC  bindings.  Parameter
ordering will also place platform specific elements or communication layer
specific elements at the correct location.  This includes placing the opcode
at the first position, or, if on L4 version 2 transferring flexpages, just
behind the flexpage descriptors.

Besides that, fixed sized (simple) elements should come first, then
inidirect parts. Flexpages (in V4 speak map and grant items) come last for
V4 (X.2) and first for V2.  For V2 we also have to place a delimiter zero
flexpage behind flexpages.

Some sidenote: Even though it is possible to transfer more than one flexpage
with V2 this is normally not done.  So the special case of one flexpage should
be optimized.

\subsubsection{Marshaling}
Marshaling could be done by simply calling a marshal function of the
message buffer.  If it is marshaling it marshals---depending on the
communication function---the \verb|_in| \verb|struct| or, if unmarshaling,
the \verb|_out| \verb|struct|.

\subsubsection{Invocation}
Upon message invocation, the third member of the union is used to load the
message---for X.2---or use it a reference to the message buffer.  Thus,
depending on the marshaling algorithm, the specific elements of the message
(send and size dopes) do not have to be set in the \verb|_in| or \verb|_out|
\verb|struct|, but could be set in the \verb|_msg| \verb|struct|.  The
\verb|_in| and \verb|_out| \verb|struct| could contain placeholders instead of
these members.  However, this depends on the marshaling algorithm.
