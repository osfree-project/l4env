\section{Classes}
\label{sec:classes}

The source of the \dice{} project is divided into a parser, a
front-end and a back-end.  The parser is responsible for parsing
the IDL files and creating an in-memory representation of the
IDL files.  This in-memory representation is generated from the
front-end classes (denoted by the \verb|CFE| prefix).  So, strictly
speaking, the front-end of the compiler is the parser, which does
the lexical and semantic analysis.  The front-end classes are the
abstract syntax tree (AST) of the input (the IDL files).  Some of
the semantic analysis is done in the \verb|CheckConsitency| method
of the front-end classes.

Using compiler options, it is possible to generate pre-processed
output, which is basically the input for the parser, or to dump
the AST (use \verb|-EXML|) in XML format.

The in-memory representation ofthe IDL is then transformed into 
the in-memory representation of the target code.  Because the target
code may differ depending on the selected target language, kernel
interface, and platform, it is done in two steps.  Firstly, the
classes are created using a class factory.  Secondly, the instances
are initialized using the \verb|CreateBackEnd| methods.

An IDL compiler is similar to common programming language compilers
in that it parses an input language (in this case the IDL) generates
an in-memory representation (AST) from it, transforms this AST into
an AST of the target language and writes the output.  The difference
is that a common language compiler mostly condenses code, while an
IDL compiler has to create additional logic around the input 
description.

\subsection{Back-End}
The back-end classes (or in-memory representation of the target 
code) is substructured into files, client and server, and the
code structures.  The client and server seperation is the top-most
seperation.  It is represented by the client and component class.
There also exist a test-suite class for an optional test-suite, which
is equal to the client and component.

The client and component class share some sructure, which is 
focused int the target class.  The client and component own the
files, which are created during the write process.  These files in
turn own the namespaces, classes, functions, constants, and types,
which are created from the input AST.

The structure of the target AST has been chosen to represent the
structure of the C++ language, that is, namespaces, classes, functions,
types, etc.  This is, because most common language follow a similar 
layout.  C can be represented by "flattening" namespaces and classes
and incorporating their existence into the names of constants, types,
and functions.  Java is similarely structured to C++ in that it has
namespaces, classes, and methods.

\subsubsection{Create Process}
As mentioned, the create process of the back-end is seperated into
two steps.  Firstly, each class is created using a constructor, which
is called in the class factory.  Secondly, the class' \verb|CreateBackEnd|
method is called, which receives either a front-end class (AST) or
other (back-end) parameters to initialize the instance of this class.
This two step approach leads to a ``dead-lock'' for message buffers.

A class\footnote{I.e., the target language's class, which is represented
by the class CBEClass.}---representing an interface---owns 
functions\footnote{I.e., the target language's functions, which are
represented by classes derived from CBEFunction}.  The functions are
divided into operation-functions, which are specific to a single operation,
or interface-functions, which are used for all operations of an interface.
An example for an oepration function is the \verb|call| function.  It
is specific for calling the interface and has to have no detailed knowledge
about the interface.  Its message buffer is build entirely from the
knowledge about the operation.  An interface-function, such as \verb|wait-any|,
uses the server's (interface) message buffer and is generic for the whole
server (interface).  Thus it relies on the class' message buffer.  To
initialize a class message buffer properly, all message buffers of the 
functions are scanned to determine number and size of parameters, etc.

So, when a class is created, it creates for all its operations the 
respective functions.  These functions own message buffers, which are
also created.  The interface-functions rely on the class' message buffer.
This message buffer, in turn, relies on the existence of the 
operation-functions' message buffers.  Thus, for a class we had to
divide the create process even more:

\begin{enumerate}
\item The operation-functions are created. They in turn create
\item their respective message buffer.
\item The class' message buffer is created, extracting information
      from the existing message buffers.
\item The interface-functions are created, which in turn involve
      the class' message buffer.
\end{enumerate}

The classes are depicted in Figure~\ref{figure:functions}.

\insertFigure[caption={Class hierarchy for function classes}]{functions}

\subsubsection{Output Order}
In an IDL file the usage of pre-processor macros, such as defines and
includes, and their placement determines the range of their availability.
Macros could, for instance, be redefined after they have already been 
used. Also, the order of types and includes is sometimes important.

Thus, \dice{} should generate the output in a sequence, which corresponds
to the sequence of the statements in the IDL.  To be able to write the
back-end elements in the order of their corresponding appearance in the 
IDL, the back-end classes rely on the line number in the source file.
This information is stored in the front-end classes and assigned in the
back-end classes during their creation.  For this reason, the 
\verb|CrateBackEnd| methods either have to set the \verb|m_nSourceLine| and
\verb|m_sSourceFileName| members themselves or call the \verb|CreateBackEnd|
method of the \verb|CBEObject| class.

For back-end classes created on the fly (e.g., member accessors for 
message buffer) this cannot be applied. 

When writing the target code, these line numbers are used to sort the
target code elements for writing.  Therefore, target code elements
appear in the order their respective front-end elements have been declared.

There are some elements, which are generated and can therefore not be
written according to their appearance in the IDL file. These include 
\verb|include| statements for generated (and \dice{}) header files, user
defined functions and generated types.  These elements have to be placed 
at designated spots in the generated files, preferably at the beginning.

