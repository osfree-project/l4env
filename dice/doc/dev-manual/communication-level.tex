\section{Communication Level}

The following are ideas from discussion with Alexander Warg
% and Jean Wolter
about the layering of communication abstractions.

\subsection{The Problem}
In \dice{} there exist different backends and options which all turn on or
off seperate features in the communication.  
\begin{enumerate}
\item The \verb|[noopcode]| attribute determines that there is no opcode 
      needed for a function.  
      
\item The \verb|[noexceptions]| attribute turns off transfer of exception 
      codes from the server to the client for a function.

\item The user can use the \verb|[oneway]| and \verb|[out]| attribute with a
      function to transfer a message only into one direction.
      
\item Furthermore, the user can turn off generation of dispatch and 
      server-loop to build these functions himself.

\end{enumerate}

Each of these possibilities influences the message buffer, the marshaling and
unmarshaling, and the logic around communication (for instance, no exception
checking if no exception is transmitted).

\subsection{The Idea}
Based on the ability of \dice{} to generate simple messages from an IDL, for 
instance by using \verb|[oneway]|, \verb|[noopcode]|, and \verb|[noexceptions]|
attributes, the idea of different levels of communication emerged.  The basic
level is simple data transfer.  There is no semantic to the transmitted data,
except the semantic determined by the communication layer\footnote{Maybe not
even that.}.  The layer atop of this basic layer adds opcodes to the transfered
data to uniquely identify a type of message, that is, which function signature
initiated the message.  The next layer may add exceptions to the message to
transfer error information.  This only makes sense for remote procedure call 
(RPC) semantics.  Additional layers may add dispatch functions, server loops,
CORBA services, etc.

The following sections will describe the layers in more detail.  This will also
include a description of the associated functions and what the IDL compiler has
to generate.

\subsection{Layer One}
The basic layer of communication simply transfers data from a sender to a 
receiver.  The data has no semantic, except the semantic of the communication
platform.  This involves the recognition of platform specific data types by the
marshaller and recognition of specific ocations in the message buffer.  See
section~\ref{sec:message-buffer} for details on that.

It should be possible to use all communication functions with the basic 
communication layer.  The sending functions should use a message buffer which
contains platform specific elements.  For L4 version 2: The receive flexpage,
the send and size dope.  The receiving functions should use a message buffer,
which can hold the specified parameters.  The only possible error checking
is done with the number of transferred bytes (or flexpages and indirect strings).
Variable sized parameters transmit a size in the message buffer.  This size
should be range checked to avoid invalid memory access.  When using simple
receive functions to receive buffers, no reference to the message buffer is
allowed.  The message buffer is allocated on the stack of the function and
when the functions returns the reference becomes invalid.

\subsection{Layer Two}
This layer adds opcodes at a predefined position in the message buffer to
allow for unique message identification.  The position should be at the 
beginning of the message to identify the message before starting to unmarshal
the message.

For L4 version 2 this position is the first word in the message.  The only
exception applies, if the message includes flexpages.  Because flexpages
always have to come first, they displace the opcode from the beginning of
the message.  The usage of opcodes can be turned off by using the 
\verb|[noopcode]| attribute.  This will degrade a message from layer two
to layer one.  As we will see later, this is not fully true.

For L4 experimental version X.0 the same restrictions for the opcode apply
as for L4 version 2.  Because X.0 allows to transmit three words in a
short IPC, it is possible to transfer a flexpage and the opcode in a short
IPC.  This implies a special case to the special case handling of flexpages
and opcodes,  because usually opcodes are found in the message buffer after
the terminating zero flexpage.  If there is no zero flexpage, the usage of
a short flexpage IPC with opcode has to be handled seperately.

For L4 experimental version X.2 the opcode is always part of the message
description.  There is no need to intorduce an extra communcation layer 
for opcodes, since opcodes are always present.  On layer one it is not
used, on layer two it is.

\subsection{Layer Three}
The next layer introduces error handling, that is, exceptions.  Exceptions
are used to report status information.  For communication on layer three
they are used to report communication errors.  This implies that they are
not transferred from one communication partner to the other.

\subsection{Layer Four}
This layer provides cross communication error handling.  The exception then
represents error status of the processing of a request at the server.  This 
implies the communication is RPC, that is, a client invokes a function of a
server and the exception can signal error conditions at the server.  Other
communication functions cannot reasonably use exceptions (except layer three
exceptions).  If the user specifies the \verb|[noexceptions]| attribute,
the communication drops to layer three.

Now back to a beforementioned problem: What if the user specifies the attribute
\verb|[noopcode]| for a layer three (or above) communication?  Does the 
communication layer drop to one?  What about the exception handling?  Are these
options equally valuable, that is, are layer two to four actually one layer?
We still have to evaluate this.

\subsection{Layer Five}
The client/server layer.  This layer adds a dispatch and a server-loop function.
Using these, it is possible to build a fully fledged server.  The client-server
architecture also implies other functions, which are detailed in 
Section~\ref{sec:functions}.

The client-server architecture relies on opcodes and exceptions.  If there is an
interface without functions with opcodes, the dispatch function cannot determine
which message was transferred and call the appropriate unmarshal and component
functions.  This example also shows that communication layers are associated
with functions, not interfaces.  If an interface has more than one function and
only one function without an opcode, it still has to provide a dispatch function
and server loop.  Only the function without the opcode is treated as if at layer
one.

\subsection{Layer Six}
This layer could provide support for multi-threaded servers.  The difference to 
layer five is the usage of optimization techniques when marshalling and 
unmarshalling.  If a server delegates work to another thread it does so to
immediately wait for the next request.  The work delegated to the other thread
may not include data, which holds references to the message buffer.  The original
server loop may overwrite this data.  Therefore, layer six has to guarantee
exclusive access to data at the server.

\subsection{Layer Seven}
This layer may support asynchronous servers. Asynchronous servers can also be
provided at layer six.  An asynchronous server receives a request, gives the
work another active instance.  This instance could be another server or another
thread in the same server (worker thread).  The server then starts to wait for 
the next request, but the client is kept waiting.  This layer adds the possibility
to use the attribute \verb|[allow_reply_only]|, which marks a function as 
asynchronous.  \dice{} generates one additional function for this operation.  It
sends the reply to the client not directly after returning to the server loop
(dispatch function), but when the work is finished.

For L4 version 2 and X.0 it is necessary to generate an additional function.  If
a client calls a server, it expects the reply from the same thread.  Therefore,
a worker thread cannot reply directly to the client.  It has to notify the
server loop about the finished work, which then sends the reply to the client.
The notify function provides a client stub to invoke the server and its 
implementation at the server simply calls the reply function.

\subsection{Additional Layers}
Additional layers may include provision of monitor code, security checks, 
stateful server or even CORBA compiant service handling.  Since there has been
no need for these technologies, no ideas exist on how to integrate this into
\dice{}.

