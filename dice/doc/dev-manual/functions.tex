\section{Functions}
\label{sec:functions}

This section explains functions generated by \dice{}.
This section starts with the most common scenario and becomes more detailed
when appropriate.

\subsection{RPC}
The RPC scenario consists of a client, which can invoke a number of 
methods\footnote{The term \emph{method} or \emph{operation} refers to the 
method specified in the interface description. The term \emph{function}
refers to the generated C functions.} at a server.  The server will 
dispatch incoming messages according to the included opcode to a server
implementation function.

The methods are:
\begin{itemize}
\item \textbf{\texttt{call}} The client side function to call the method
      at the server.  It marshals the parameters into the message buffer,
      invokes the communication primitive to send the message to the server,
      immediately waits for the reply, and eventually unmarshals the reply,
      which may also consist of an exception.  This is the only function
      at the client side.

\item \textbf{\texttt{server-loop}} The server loop waits for a message,
      calls the \verb|_dispatch| function and---according to its return 
      value---either sends the reply and waits for the next message or
      does not send a reply and waits for the next message immediately.

\item \textbf{\texttt{wait-any}} The server loop uses two functions to wait
      for a message and to send a reply and wait for the next message.
      This function is used for the initial waiting for any message from
      any client.

\item \textbf{\texttt{reply-wait}} This is the latter function.  It replies
      an already marshaled message to the client and waits for any message
      from any new client.  Because marshaling of the reply and sending
      of the reply are separated, meta-information has to be made available
      from the marshaling function to the reply function.  If the method
      replies with a flexpage, the reply function has to set an appropriate 
      bit in the message to inform L4 about the flexpage.  If the dispatch
      function allocated memory for \verb|[out, ref]| parameters, this memory
      has to be freed after sending the reply.

\item \textbf{\texttt{dispatch}} This function unmarshals the opcode from
      the predefined position in the message buffer and, depending on its
      value, calls the appropriate \verb|_component| function.  The dispatch
      function first calls the \verb|_unmarshal| function to unmarshal the
      \verb|[in]| parameters from the message buffer.  Then any \verb|[out]|
      parameters, which require dynamic memory, are allocated.  With the
      references and the \verb|[in]| parameters the \verb|_component| function
      is invoked.  This function actually contains the implementation of the
      method at the server.  After the function returned, the \verb|_marshal|
      function is invoked to marshal the \verb|[out]| parameters into the
      message buffer.  Then the \verb|_dispatch| function returns.

\item \textbf{\texttt{unmarshal}} The unmarshal function simply sets the values
      of the local \verb|[in]| parameters to the values in the message buffer.
      Arrays and strings are usually references into the message buffer to 
      avoid unnecessary copy operation.  Because C does not allow to specify
      reference parameters, all parameters have to be references.

\item \textbf{\texttt{component}} The component function is usually only 
      declared in the server header file.  It has to be implemented by the 
      user.  We tried to use the same function signature as with the 
      \verb|_call| function.  This was not possible.  The \verb|_component|
      function takes a \verb|CORBA_Server_Environment| as last parameter
      as opposed to the \verb|CORBA_Environment| of the \verb|_call|
      function.

\item \textbf{\texttt{marshal}} The marshal function marshals all \verb|[out]|
      parameter into the message buffer.
\end{itemize}

\subsection{Oneway}

The \verb|[oneway]| attribute allows to send a message to a server, without
waiting for a reply.  The message still contains an opcode, so the server 
can call the appropriate \verb|_component| function.  \dice{} also generates
a \verb|_recv| and a \verb|_wait| function for the \verb|[oneway]| method.
These functions can be used without the server loop to receive a oneway
message.  The generated functions are:

\begin{itemize}
\item \textbf{\texttt{send}} This function is generated instead of the 
      \verb|_call| function. It marshals the message, sends the message
      to the receiver, and check communication errors.

\item \textbf{\texttt{recv}} This function waits for a message from a specific
      sender.  This is the closed wait of L4.  It then checks the opcode
      and if it matches the expected opcode starts unmarshaling the parameters.
      If the opcode does not match an exception is set (wrong opcode) and the
      caller can decide on how to handle this error.

\item \textbf{\texttt{wait}} Similar to the \verb|_recv| function, but the
      message can be sent by any sender.

\item \textbf{\texttt{unamrshal}} The dispatch function has to unmarshal the
      \verb|[in]| parameters.

\item \textbf{\texttt{component}} This function is called by the dispatch 
      function if the message is received by the server loop.
\end{itemize}

\subsection{Oneway Out}

The is also a oneway attribute for the direction from the server to the client.
This is the \verb|[out]| attribute simply specified with a function.  The 
generated functions are:

\begin{itemize}
\item \textbf{\texttt{send}} This time at the server side.  Thus the server can
      send the message to any other thread.

\item \textbf{\texttt{recv}} This function is generated at the client side and
      has the same semantic as for the \verb|[oneway]| attribute.

\item \textbf{\texttt{wait}} Ditto.

\item \textbf{\texttt{unmarshal}} This function is generated to unmarshal the 
      parameters from a message buffer. The reason for the generation of this
      and the next function is explained below.

\item \textbf{\texttt{wait-any}} Works similar as the wait any function of the
      RPC scenario.
\end{itemize}

Assuming you have an interface containing a \verb|[oneway]| method.  Then it 
is obvious to generate the \verb|_send|, \verb|_recv|, and \verb|_wait| 
functions.  Lets call this method \verb|func1|.  Now the user adds another
\verb|[oneway]| method to the interface---\verb|func2|.  \dice{} generates
the three function for it as well.  The user now wants to receive at one point
both messages.  So \dice{} would have to generate functions 
\verb|_func1_or_func2_recv| and \verb|_wait|.  This may still seem ok.  Now
the user adds another function \verb|_func3| and wants to receive any possible
permutation of methods.  So \dice{} would have to generate three more 
functions for one added method.  To avoid the exponential explosion of 
generated functions, one additional function is generated to receive any 
message (\verb|_wait_any|).  This function returns the opcode of the message.
The opcode can be used to call the appropriate \verb|_unmarshal| function.

\subsection{Asynchronous Communication}
You can specify the attribute \verb|[allow_reply_only]| with a method.
This allows the \verb|_component| function to set an additional parameter
(\verb|_dice_reply|) to \verb|DICE_NO_REPLY|.  The server loop will then
neither marshal the \verb|[out]| parameters nor send a reply to the client,
but wait for the next message.  \dice{} generates an additional function 
for this method (\verb|_reply|) that has the \verb|[out]| parameters as
parameters and can be used to send a deferred reply to the client.

In the near future \dice{} will also automatically generate for the
L4 version 2 and X.0 platform \verb|_notify| functions, which can be called
by a worker thread to send the reply to the client from the server thread.
L4 version 2 and X.0 do not support propagation IPC, which would allow to
switch the communication partner of the client from the server loop thread
to the worker thread.

