\section{Functions}
\label{sec:functions}

This section explains functions generated by \dice{}.  This section starts
with the most common scenario and becomes more detailed when appropriate.

\subsection{RPC} 

The RPC scenario consists of a client, which can invoke a number of
methods\footnote{The term \emph{method} or \emph{operation} refers to the
method specified in the interface description. The term \emph{function} refers
to the generated C functions.} at a server.  The server will dispatch incoming
messages according to the included opcode to a server implementation function.

The methods are:
\begin{itemize}
\item \textbf{\texttt{call}} The client side function to call the method
      at the server.  It marshals the parameters into the message buffer,
      invokes the communication primitive to send the message to the server,
      immediately waits for the reply, and eventually unmarshals the reply,
      which may also consist of an exception.  This is the only function
      at the client side.

\item \textbf{\texttt{server-loop}} The server loop waits for a message,
      calls the \verb|_dispatch| function and---according to its return 
      value---either sends the reply and waits for the next message or
      does not send a reply and waits for the next message immediately.

\item \textbf{\texttt{wait-any}} The server loop uses two functions to wait
      for a message and to send a reply and wait for the next message.
      This function is used for the initial waiting for any message from
      any client.

\item \textbf{\texttt{reply-wait}} This is the latter function.  It replies
      an already marshaled message to the client and waits for any message
      from any new client.  Because marshaling of the reply and sending
      of the reply are separated, meta-information has to be made available
      from the marshaling function to the reply function.  If the method
      replies with a flexpage, the reply function has to set an appropriate 
      bit in the message to inform L4 about the flexpage.  If the dispatch
      function allocated memory for \verb|[out, ref]| parameters, this memory
      has to be freed after sending the reply.

\item \textbf{\texttt{dispatch}} This function unmarshals the opcode from
      the predefined position in the message buffer and, depending on its
      value, calls the appropriate \verb|_component| function.  The dispatch
      function first calls the \verb|_unmarshal| function to unmarshal the
      \verb|[in]| parameters from the message buffer.  Then any \verb|[out]|
      parameters, which require dynamic memory, are allocated.  With the
      references and the \verb|[in]| parameters the \verb|_component| function
      is invoked.  This function actually contains the implementation of the
      method at the server.  After the function returned, the \verb|_marshal|
      function is invoked to marshal the \verb|[out]| parameters into the
      message buffer.  Then the \verb|_dispatch| function returns.

\item \textbf{\texttt{unmarshal}} The unmarshal function simply sets the values
      of the local \verb|[in]| parameters to the values in the message buffer.
      Arrays and strings are usually references into the message buffer to 
      avoid unnecessary copy operation.  Because C does not allow to specify
      reference parameters, all parameters have to be references.

\item \textbf{\texttt{component}} The component function is usually only 
      declared in the server header file.  It has to be implemented by the 
      user.  We tried to use the same function signature as with the 
      \verb|_call| function.  This was not possible.  The \verb|_component|
      function takes a \verb|CORBA_Server_Environment| as last parameter
      as opposed to the \verb|CORBA_Environment| of the \verb|_call|
      function.

\item \textbf{\texttt{marshal}} The marshal function marshals all \verb|[out]|
      parameter into the message buffer.
\end{itemize}

\subsection{Oneway}

The \verb|[oneway]| attribute allows to send a message to a server, without
waiting for a reply.  The message still contains an opcode, so the server can
call the appropriate \verb|_component| function.  \dice{} also generates a
\verb|_recv| and a \verb|_wait| function for the \verb|[oneway]| method.
These functions can be used without the server loop to receive a oneway
message.  The generated functions are:

\begin{itemize}
\item \textbf{\texttt{send}} This function is generated instead of the 
      \verb|_call| function. It marshals the message, sends the message
      to the receiver, and check communication errors.

\item \textbf{\texttt{recv}} This function waits for a message from a specific
      sender.  This is the closed wait of L4.  It then checks the opcode
      and if it matches the expected opcode starts unmarshaling the parameters.
      If the opcode does not match an exception is set (wrong opcode) and the
      caller can decide on how to handle this error.

\item \textbf{\texttt{wait}} Similar to the \verb|_recv| function, but the
      message can be sent by any sender.

\item \textbf{\texttt{unamrshal}} The dispatch function has to unmarshal the
      \verb|[in]| parameters.

\item \textbf{\texttt{component}} This function is called by the dispatch 
      function if the message is received by the server loop.
\end{itemize}

\subsection{Oneway Out}

The is also a oneway attribute for the direction from the server to the client.
This is the \verb|[out]| attribute simply specified with a function.  The 
generated functions are:

\begin{itemize}
\item \textbf{\texttt{send}} This time at the server side.  Thus the server can
      send the message to any other thread.

\item \textbf{\texttt{recv}} This function is generated at the client side and
      has the same semantic as for the \verb|[oneway]| attribute.

\item \textbf{\texttt{wait}} Ditto.

\item \textbf{\texttt{unmarshal}} This function is generated to unmarshal the 
      parameters from a message buffer. The reason for the generation of this
      and the next function is explained below.

\item \textbf{\texttt{wait-any}} Works similar as the wait any function of the
      RPC scenario.
\end{itemize}

Assuming you have an interface containing a \verb|[oneway]| method.  Then it
is obvious to generate the \verb|_send|, \verb|_recv|, and \verb|_wait|
functions.  Lets call this method \verb|func1|.  Now the user adds another
\verb|[oneway]| method to the interface---\verb|func2|.  \dice{} generates the
three function for it as well.  The user now wants to receive at one point
both messages.  So \dice{} would have to generate functions
\verb|_func1_or_func2_recv| and \verb|_wait|.  This may still seem ok.  Now
the user adds another function \verb|_func3| and wants to receive any possible
permutation of methods.  So \dice{} would have to generate three more
functions for one added method.  To avoid the exponential explosion of
generated functions, one additional function is generated to receive any
message (\verb|_wait_any|).  This function returns the opcode of the message.
The opcode can be used to call the appropriate \verb|_unmarshal| function.

\subsection{Asynchronous Communication}
You can specify the attribute \verb|[allow_reply_only]| with a method.
This allows the \verb|_component| function to set an additional parameter
(\verb|_dice_reply|) to \verb|DICE_NO_REPLY|.  The server loop will then
neither marshal the \verb|[out]| parameters nor send a reply to the client,
but wait for the next message.  \dice{} generates an additional function 
for this method (\verb|_reply|) that has the \verb|[out]| parameters as
parameters and can be used to send a deferred reply to the client.

In the near future \dice{} will also automatically generate for the
L4 version 2 and X.0 platform \verb|_notify| functions, which can be called
by a worker thread to send the reply to the client from the server thread.
L4 version 2 and X.0 do not support propagation IPC, which would allow to
switch the communication partner of the client from the server loop thread
to the worker thread.

\subsection{Dependencies of message buffer, communication, and functions}

Currently, a function class ``owns'' instances of the message buffer, the 
communication class, and the marshaller (besides some others).  The type of 
function highly influences the way the communication class is used, that is, 
which method of the communication class is invoked.  Therefore, we could claim 
to create derived classes of the communication class, which implement one of 
the methods to write communication code, i.e., one 
\texttt{CBESendCommunication}, one \texttt{CBEReceiveCommunication}, etc.  Then
the communication class used by a function depends on the function: a send
function requires a send communication class.

Depending on the communication class the message buffer is constructed.  A
send communication does not require a receive part in the message buffer.
Three or four types (classes) of message buffers might suffice: one for send
only, one for receive only, and one for both direction.  Possibly an extra
class for servers might be required---the fourth type of message buffer.

The layout of the message buffer also influences the way the marshalling class
works.  Therefore does the message buffer type determine which sort of
marshalling is used.  For the L4 API it might even show that a short IPC
(becoming an own special sort of communication) does not require an message
buffer at all, and therefore requires no marshalling.  Instead the
communication class arranges the parameters in its own fashing (reusing parts
of the marshallers code).

One thought concerned the order of invocations of the method calls to write
the code of a function.  It seemed not applicable to write variable
declarations of the message buffer via the communication class.  But, if the
communication class, and with it the message buffer, added their local
variable upon construction to the function, this might not be a problem.  So
the function class calls the communication code's invocation function, which
in turn has to initialize the message buffer, and marshal it using the
marshaller class.  The marshaller is currently accessed by the communication
class only, except for tracing, which can be moved to the marshaller or to the
communication class.  Therefore it seems natural to access the marshaller only
via communication class.

A disadvantage of this approach is that adding hooks cannot be done
``globally'' on function class level, but has (possibly) to be distributed
into the different classes.  It also seems that we would end up with moving
basically all code from the functions into the communication or marshalling
class.  A solution to the loss of fine-grained control from the
functions---e.g. to unmarshal single values---is the provision of fine-grained
methods.  So instead of writing CBECommunication::Write(), have fine grained
methods in the communication class that respond to the already existing steps.
The communication class can then delegate the calls to the appropriate methods
in the message buffer or marshalling class.  Or, what is much easier, simply
obtain a reference to the communication class' marshaller and call its
marshalling methods.

However, I think the message buffer should be owned by the function class and
the class class, because it has properties that correspond to them
respectively.  And since the class class has no communication class associated
with it, it would have no message buffer.  Thus, the message buffer belongs to
the class class.  Same holds for some functions, such as server loop,
dispatcher, and component function.

\subsubsection{Solution}

A function class and the class class have a reference to the message buffer
class, because the message buffer might also be used as parameter, whithout
the need of either marshalling or communication.

A function class has a reference to the communication class that is
initialized if required.  This is, because some functions might use
communication primitives, while others don't.

A function class also has a reference to the marshalling class that is
initialized if required.  This is, becuas some functions require marshalling
code and some don't.  Especially the marshalling class is independent of the
communication class, since some functions (such as unmarshal or marshal)
require a marshal class, but not a communication class.

Marshaling and communication class require however a message buffer class, so
it has to be created before the marshaller and communication class.
