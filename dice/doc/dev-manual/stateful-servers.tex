\section{Statefule Servers}

This section is the result of a discussion with Martin.

The phrase \emph{sateful servers} is used in the sense of servers, which
hold a state, can change the state, and use certain actions, such as
messages to transfer from one state to another.  Besides messages the 
occurence of timeouts is also considered an action.

\subsection{Handwritten Stateful Servers}
Stateful servers can be modelled without requiring special support by \dice{}.
The server has to hold a state and whenever a message occurs, it checks if
this action is allowed in the current state and initiates a respective 
response.

Lets have a look at an example: Consider a simple parser, which receives
messages whenever a letter has been scanned.  The server returns whether
the parsed sequence of letters is valid or not.  Furthermore lets assume
the onyl valid sequence is ``sooooooooo hot'', where ``so'' can be written
with an arbitrary number of at least one, but nor more that 20 `o's.  The
server initializes the internal states and waits for any message.  If
a valid character is sent to the server, it initiates the appropriate state
change and returns that the sequence is valid.  If an invalid character is
sent to the server it checks in the \verb|_component| function that the
letter is invalid and returns with an invalid sequence value.

The IDL could look like this:

\begin{verbatim}
typedef enum { VALID, INVALID } sequence_type;

interface parser
{
  sequence_type letter([in] char letter);
};
\end{verbatim}

The implementation of the \verb|_component| function could look like this:

\begin{verbatim}
static int state = 0;
static int num_o = 0;

sequence_type
parser_letter_component(CORBA_Object _dice_corba_object,
  CORBA_char letter,
  CORBA_Server_Environment _dice_corba_env)
{
  switch (state)
  {
  case 0: // accept only 's'
    if (letter != 's')
      return INVALID;
    state = 1;
    break;
  case 1: // accept up to 20 'o's
    if (letter != 'o')
      return INVALID;
    if (++num_o > 20)
      return INVALID;
    if (num_o == 20)
      state = 2;
    break;
  case 2: // accept ' '
    if (letter != ' ')
      return INVALID;
    state = 3;
    break;
  case 3: // accept 'h'
    if (letter != 'h')
      return INVALID;
    state = 4;
    break;
  case 4: // accept 'o'
    if (letter != 'o')
      return INVALID;
    state = 5;
    break;
  case 5: // accept 't'
    if (letter != 't')
      return INVALID;
    state = 6;
    break;
  default:
    return INVALID;
  }
  return VALID;
}
\end{verbatim}

If you want to specify that there should be timeouts between the message, even
that can be specified.  Lets say the server should wait infinite time until the
first letter arrives, but then the messages should arrive with a interarrival
time of maximal $100ms$.

The \verb|_component| function has to set the timeout member of the environment
to the value of $100ms$.  To return an invalid sequence to the client an error
function has to be specified, which handles the IPC timeout.  Because the error
function has not communication partner, it cannot reply the invalid sequence to
the client but has to set an error status.  When the next message arrives, the 
error status has to be checked and returned to the client.

\subsection{Support for Stateful Servers}
As you have seen, the code for the \verb|_component| function looks pretty 
generic---at least the part with the state checks.  Such code could be generated
by the IDL compiler as well.

