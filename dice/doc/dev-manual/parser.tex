\section{Parser}

The parser of \dice{} is generated with yacc/lex (bison/flex) from
grammar files.  The grammars have been taken from publicly available
websites and sometimes been modified to, for instance, include gcc
extensions.

\subsection{File Import}
\dice{} supports the notion of \verb|import| and \verb|include|.  The 
\verb|import| statement is only known to the DCE IDL and is defined
in \cite{midl-import} as:

\begin{quote}
With the import directive, all IDL statements in the imported file, 
such as typedefs, constant declarations, and interface definitions 
become available to the importing .IDL file.

The imported file is processed separately (meaning that CPP 
preprocessor is invoked independently) from the importing IDL 
file. In this way, pre-processor directives, such as \verb|#define|, 
do not carry over from an imported header or IDL file to the 
importing IDL file.

Like the C-language preprocessor macro \verb|#include|, the \verb|import|
directive tells the compiler to include data types that were defined 
in the imported IDL files. Unlike the \verb|#include| directive, the 
import directive ignores procedure prototypes, since no stubs are 
generated for anything in the imported file.

[...]

The C-language header (.H) file generated for the interface does 
not directly contain the imported types but instead generates a 
\verb|#include| directive for the header file corresponding to the 
imported interface. For example, when you import BASE.IDL into your 
DERIVED.IDL, the generated header file DERIVED.H will contain the 
directive \verb|#include BASE.H|.

The following rules apply:
\begin{itemize}
\item The import keyword is optional and can appear zero or more times 
      in the IDL file.
\item Each import keyword can be associated with more than one file name.
\item Separate multiple file names with commas.
\item You must enclose the file name within quotation marks and end the 
      import statement with a semicolon (;).
\item You can import an interface that has no attributes into another 
      IDL file. However, the interface must contain only datatypes; it 
      cannot contain any procedures. If even one procedure is contained 
      in the imported interface, you must specify a local or UUID attribute.
\item The import function is idempotent---that is, importing an interface 
      more than once has no additional effect.
\end{itemize}
\end{quote}

\subsection{File Includes}
\verb|#include| statements are evaluated by the pre-processor and may
therefore contain only code that is valid IDL grammar.

\subsection{Pre-processing Files}
The specified pre-processor (default is gcc) is used to generate an 
intermediate file from the given IDL file.  The pre-processor will
evaluate the pre-processor commands (denoted by \verb|#|) and include
any given files.

Because bison and flex are not really able to generate object-oriented,
that is, C++ parsers that are fully self-contained, it is not easily 
possible to set up an own parser for each imported file.  Therefore,
\dice{} applies some modified rules to the definition of import: 
import is treated as include, that is, an imported file is not pre-processed
in its own context.  But imported files only include types, and other
IDL conformant statements.

Because gcc as a pre-processor might strip some include statements from
a file when the included file has appeared before, we have to remember
all import and include statements, so they will appear at the right
position in the target code. (Even though one migth argument that they
would be eliminated in the target code as well.) \dice{} therefore
scans each file for include and import statements before pre-processing
it. While doing so, it also replaces import with include statements and
tries to parse the included files as well.  This is done by the scanner
in \verb|src/parser/inc|.  This pre-pre-processor generates intermediate
files for the pre-processor.  The pre-processor (gcc) then processes 
these intermediate files to generate the intermediate file, which is 
then parsed for IDL code.  The output of the pre-processor is dumped to
stdout if the option \verb|-E| is given.

\subsection{Parsing the input}
The output of the pre-processor is then used to generate the in-memory
presentation of the IDL.  Because the pre-processor produced one big
file as output, the parser has to extract its knowledge about included
files from the pre-processed data.  Gcc generates directives which  
denote where the text came from, which have a simple syntax:

\begin{verbatim}
# <line> "<file>" <num>
\end{verbatim}

Where:

\begin{description}
\item[line] is the original line number of the next line
\item[file] is the name of the file that contributed the following lines
\item[num] some additional information, which will be explained below.
           (this is optional)
\end{description}

So a line like \verb|# 12 "test.idl"| specifies, that the next line came
from file \verb|test.idl| and was line number 12.  The pre-processor uses
this statement to skip empty lines and generate shorter intermediate files.

The \verb|<num>| can have the values one (1) to four (4).  
\begin{itemize}
\item One (1) specifies the start of a file.  Thus, the line 
      \verb|# 1 "test.h" 1| specifies that the next line is the 
      first line of the included file \verb|test.h|.
\item Two (2) specifies the end of a file.  The line 
      \verb|# 13 "test.idl" 2| means that the previous file ends and
      the next line is from file \verb|test.idl| and was line number 13.
\item Three (3) indicates that the following text comes from a system
      header file. \dice{} treats 3 as if it is 1.
\item Four (4) indicates that the following text (until next 2) should
      be treated as if wrapped in extern "C" statements.  \dice{}
      ignores this number.
\end{itemize}

Therefore, statements without \verb|<num>| should only update the line 
number information of the parser.  The file name should stay the same.

However, statements with \verb|<num>| have to update the in-memory 
representation to reflect current file scopes.

Because different input has different syntax and we tried to keep the 
grammar files as simple as possible, there exist four different 
parsers.  One for DCE IDL, one for CORBA IDL, one for C files, and one
for C++ files.  To manage them in \dice{} their status is wrapped
using parser classes, which are \verb|CDCEParser|, \verb|CCORBAParser|,
\verb|CCParser|, and \verb|CCXXParser| respectively.  

Whenever a new file is encountered, it is checked if the current parser
can handle it.  There is no need to create a new C parser if we are
already parsing C files.  If no new parser is needed, only the current
file scope has to be updated.  When a new file is encountered (num 1) a
\verb|CFEFile| class is created, added to the current file, and made
current file.  When the end of a file is encountered (num 2), \dice{}
checks if the outer file was from a different parser.  If so, the parser
is changed.  If not, the file scope is simply changed.

With bison it is simple to parse different files with one parser, but 
it becomes complicated if we want to parser one file with multiple
parsers.  Whenever the scanner finds the start of a new file it calls
the current parser's \verb|Import| method.  The \verb|Import| method
decides, depending on the file extension, if it should create a new
parser or continue using the current parser.  This decision is also
signalled to the scanner, so it can update status information as well.

If a new parser is created, its \verb|Parse| method is called, which
eventually switches the input buffer of the scanner, thus resetting the
status information of the scanner lib.  Then the parse method is called
(for instance, \verb|dceparse| for DCE IDL), which itself calls the
scan method to obtain tokens.

One problem is the switching back, for instance from a C file to
an IDL file.  Assume the IDL file has been parsed up to line 9 and
then \dice{} switched to a C file, which implies the change of the
parser class.  Then (while parsing in C context), the end of C
file statement appears and denotes a new line number for the IDL
file, which is larger than 9 because some lines have been skipped by
gcc.  Now the C parser has to tell the DCE parser the new line number.
This is done using the \verb|UpdateState| method.
