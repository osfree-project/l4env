/* $Id$ */

/**
\defgroup frontend The Compiler's Front-End
\brief These files and classes contain the code to parse the IDL files and generate the \
 in-memory representation of the IDL files.
*/

/*
\defgroup frontend The Front-End Classes
\brief These classes and functions all belong to the front-end module of the DICE compiler.

<h3>Content</h3>
-# \ref fe_parser "The Parser"
-# \ref fe_scanner_ll "scanner.ll"
-# \ref fe_parser_yy "parser.yy"
-# \ref fe_namespace "The Name Space Concept"
-# \ref fe_crossreference "Cross References"
-# \ref fe_expressiontypecheck "Checking the Type of an Expression"
-# \ref fe_datarepresentation "The Data Representation"
-# \ref fe_acffile "The ACF File"

<h3>Introduction</h3>

The front-end consist of an parser, which reads the IDL file (and the ACF file) to 
create an in-memory	presentation of these files. This in memory presentation contains cross-references 
between interfaces or functions, e.g. to link the use of a type to it's definition. Those classes are 
prefixed <b>CFE</b>. The parser also generates a representation for the data to be transmitted. This 
data-representation is referenced in the front-end classes, so the back-end generator has indirect access 
to the data-representation through the front-end.

To check the syntax and grammar of the IDL and ACF files an <a href="grammar.html">EBNF</a><sup>
\ref footnote1 "1"</sup> has been defined. This syntax and grammar of the IDL is closely related
to the DCE IDL and has been extended to support inheritance and the concept of libraries. This evolution
is closely coupled to the IDL the Microsoft IDL compiler supports. I do not propose to support the Microsoft
IDL, because the compiler doesn't (maybe sometime).

\todo The compiler has to support the CORBA IDL as well to be a real alternative to other
compilers

<h3>The Parser</h3>
\anchor fe_parser 

The parser is generated using bison (a yacc derivate) and lex. These tools require two input files:
<code>parser.yy</code> and <code>scanner.ll</code>. The latter scans the input file and replaces keyword
with token, thus analyzing the input syntactically. The file <code>parser.yy</code> contains the
rules to check the grammar of the input. It also contains the code, which generates the in-memory
representation of the IDL. To change the grammar of the IDL you have to modify (probably) both files.
How these files are structure is described below. Whenever the IDL compiler is started the IDL file
to be read is opened by the parser generated by the bison tool. It requires tokens from a lexical 
analyzer function. This function is produced by the lex tool. One might say the parsed file first
passes the lexical analysis (lex) and it's &quot;output&quot; is used by the grammatical analyzer 
(bison).<div class="textimportant">For a detailed description of the files syntax see the user's manuals
of these tools. This is a brief description of the syntax to allow you to modify the files quickly</div>

<h3>scanner.ll</h3>
\anchor fe_scanner_ll 

The <code>scanner.ll</code> file consits of three sections, which are seperated by the characters 
&quot;<code>%%</code>&quot;, which have to be placed on the beginning of an own line. The first section 
contains definitions, the second rules and the last user code. The first section may contain name definitions
of the kind:<br>
<code><name> <definition></code><br>
The definition can later be referred to using &quot;<code>{<name>}</code>&quot;, which 
will be expanded to &quot;<code>(<definition>)</code>&quot;.<br>
<b>sample:</b> <code>DIGIT [0-9]</code>

The second section contains rules to convert the appearance of some string to some 
(usually) action. An entry in this section may look like this:<br>
<code><pattern> <action></code><br>
Whenever the parser finds a &quot;<code><pattern></code>&quot; it will execute 
&quot;<code><action></code>&quot;.<br>
<b>sample:</b> <code>';' return SEMICOLON;</code>

The definitions and rules section may contain code within 
&quot<code>%{ ... %}</code>&quot; where the &quot;<code>%{</code>&quot; and &quot;<code>%}</code>&quot; 
have to stand on a line by themselves. The code within the braces is copied verbatim to the output file. 
At the beginning of the rules section before the first rule it might be used to declare variables local 
to the scanning routine. At other locations within the rules section the behaviour of the scanning routine 
will be undefined and may result in runtime errors. See the lex man pages for a detailed description of 
the pattern syntax. The scanner	matches the scanned text to the &quot;<code><pattern></code>&quot; 
and whenever finding a equal &quot;<code><pattern></code>&quot; will execute the 
&quot;<code><action></code>&quot;. Do exist similar &quot;<code><pattern>s</code>&quot; the 
one with the most matching text will be used. Do exist equal &quot;<code><pattern>s</code>&quot; of 
the same length the first pattern listed in the <code>scanner.ll</code> file will be used.

The user code section is copied as is to the lex C-file which will be used for the 
lexical analysis by the compiler.

<h3>parser.yy</h3>
\anchor fe_parser_yy 

The parser file consits of several distinct parts. First is the part enclosed by the 
&quot;<code>%{ ... %}</code>&quot; pair. This part is written to the parser.c file as is. Next is a type 
union enclosed by &quot;<code>%union{ ... }</code>&quot;. It contains all types	a rule may return as result. 
It also defines alias names for those types. I started all names by an underscore. The syntax of an entry 
in this union is:<br>
<code><type> <aliasname>;</code><br>
This defines the alias <code>_union_case</code> for the return type <code>CFEunionCase*</code>.<br>
<b>sample:</b> <code>CFEunionCase* _union_case;</code>

Next is the section of tokens. A token is a group of characters with a special meaning. 
Usually every keyword is represented by a token. The syntax of a token definition is:<br>
<code>%token <tokenname></code><br>
<b>sample:</b> <code>%token BOOLEAN</code><br>
Which defines the token <code>BOOLEAN</code>. Some symbols (e.g. one character symbols) are not defined as 
tokens. They appear as single characters enclosed by single quotes in the rules.

After the token section follows the type section. This section connects the return
types defines in the first part with the rules, which return these types. An entry in this part might look 
like this:<br>
<code>%type <alias> <rule>;</code><br>
<b>sample:</b> <code>%type <_union_case> union_case;</code><br>
Which means: the rule <code>union_case</code> returns data of the type <code>_union_case</code> which has 
been defined to be an alias for <code>CFEUnionCase*</code>. So the rule <code>union_case</code>	returns 
pointers to <code>CFEUnionCase</code> objects.

The previous parts are separeted from the following section by an 
&quot;<code>%%</code>&quot;. The following section includes the rules of the IDL's syntax and grammar. 
The syntax is defined like this: some symbols in a defined order make a new symbol. For instance an 
<code>interface_header</code> followed by a <code>{</code> and an <code>interface_body</code>
and a <code>}</code> define an <code>interface</code>. In the parser file the rule is written this way:<br>
<b>sample:</b><br>
<code>interface<br>
: interface_header '{' interface_body '}'<br>
;</code>

The trailing &quot;;&quot; defines the end of a rule. The &quot;:&quot; says: behind me 
is what the <code>interface</code> has to be made of. The symbols <code>interface_header</code> and 
<code>interface_body</code> are the names of other rules. If the rule contains a &quot;|&quot; as it does 
in:<br>
<b>sample:</b><br>
<code>interface_header<br>
: LBRACKET  interface_attributes rbracket INTERFACE Identifier ':' Identifier<br>
| LBRACKET  interface_attributes rbracket INTERFACE Identifier<br>
;</code><br>
it means that an <code>interface_header</code> might consist of either the symbols following the 
&quot;:&quot; or the symbols following the &quot;|&quot;. The branch of symbols following the &quot;|&quot; 
is also called an alternative rule. A rule might contain multiple alternative rules.

Following each branch of a rule is a section starting with an opening brace and ending 
with a corresponding closing brace. Inside these braces are statements which will be executed if
this branch matches the syntax of the input file. The statements are usual C++ statements creating
objects or manipulating them. The variables starting with a &quot;$&quot; sign are place holder
for the symbols of that branch. The numberation starts with 1. Thus in the above rule $2 would
be a place holder for whatever the <code>interface_attributes</code> rule returns. $$ stand for 
what the rule will return itself.

Following the rules another <code>%%</code> marks the beginning of the last section. 
Everything inside this section is copied as is into the target parser source code. This is the place to 
write implementations of functions declared in the very first section.

Note that I used character constants for simple characters such as ':', ';', etc. 
Using the literal string instead of defining tokens is (IMHO) more readable. For each token bison creates 
a <code>#define</code> statement which is replaced by a lookup. Using the character / string constants 
omits the <code>#define</code> and uses the character value or string directly. For each defined token a 
return value is specified and could be used. This is not necessary for those characters or simple strings.

As result of this parser definition a function called <code>yyparse()</code> is created. 
This function is called in the <code>main()</code> function of the compiler to parse the given IDL file.

<h3>Name Spaces</h3>
\anchor fe_namespace 

To be able to check the user defined identifiers, given in the IDL, the parser needs a tool or algorithm to 
parse all the names given so far. I tried to solve this by using a name space hierarchy. This hierarchy 
represents all the names defined in the IDL. Does the IDL define a name the parser has to check wether the 
name already exists, which would result in an error, or not, then the name would be added to the hierarchy. 
Is a name used in the IDL the parser has to check if the name exists. If it doesn't exist the parser would 
generate an error.

Because two functionalities have to be supported, we implemented two functions 
<code>CheckAndAddName</code> and <code>CheckName</code>. The two functions return different	types. The first 
returns a pointer to a name space node in the hierarchy, which is <code>NULL</code> if the name already 
exists or a pointer to the node if the name has been added. The pointer is returned so the parser can use 
it as entry node for further checks. The later function returns <code>true</code> or <code>false</code> 
depending on wheter the  name exists or not.

The top node of the hierarchy is the <code>ROOT</code> node. It has no name associated 
with it. Childs of the top node can be libraries, interfaces, type definitions and const definitions 
(see grammar). Childs of a library definition can be interface definitions, type definitions and const 
definitions. Childs of an interface definition can be type definitions, const definitions and operation 
definitions. Childs of an operation definition can be parameter definitions. Type and const definitions 
do not have child definitions. 

When a check function is called it receives the name to be checked and the type of 
identifier it should be. Each type of node in the hierarchy has a different kind to	check whether the 
name exists or not. For instance does a operation node checks wether a parameter name exists by checking 
all child nodes. A parameter node checks the name of a parameter by asking its parent which is (hopefully) 
an operation. Does the operation node encounter that one of its children is the wanted parameter it returns 
true (or NULL - depending on the check function called). Different rules exists on how to handle a check 
call. See the table below for the implemented rules.

<table width="100%" border="1" class="textbody" cellspacing="0">
<tr>
	<td bgcolor="lightgrey">type to be checked</td>
	<td bgcolor="lightgrey">checking type</td>
	<td bgcolor="lightgrey">rule</td>
</tr>
<tr>
	<td>interface</td>
	<td>interface</td>
	<td>if parent exists ask parent,<br>otherwise return false</td>
</tr>
<tr>
	<td>interface</td>
	<td>root</td>
	<td>check childs of type interface on name;<br>if no interface child with name exists
	add the given name (if function is CheckAndAddName) and return false / pointer<br>
	if interface child with name exists return true / NULL</td>
</tr>
<tr>
	<td colspan="3" height="2px"></td>
</tr>
<tr>
	<td>type definition</td>
	<td>type definition</td>
	<td>...</td>
</tr>
</table>

<h3>Checking the Type of an Expression</h3>
\anchor fe_expressiontypecheck 

Only checking names is not sufficient for expressions, especially the expressions of
const definitions. The parser has to check whether the type specified for the expression does match with
whatever is defined in the expression. I introduced a function <code>IsOfType</code> into the expression
classes. So each class can decide itself if it's content corresponds to the given type. The function 
receives as an parameter a <code>TYPESPEC_TYPE</code> value. Below I specified which class does match
with which type (only the types relevant for consts are specified).

<table width="100%" border="1" class="textbody" cellspacing="0">
<tr>
	<td></td>
	<td colspan="5" bgcolor="lightgrey" align="center"><code>TYPESPEC_TYPE</code> value</td>
</tr>
<tr>
	<td bgcolor="lightgrey" align="center"><code>EXPR_TYPE</code></td>
	<td align="center"><code>TYPE_INTEGER</code></td>
	<td align="center"><code>TYPE_CHAR</code></td>
	<td align="center"><code>TYPE_BOOLEAN</code></td>
	<td align="center"><code>TYPE_VOID_ASTERISK</code></td>
	<td align="center"><code>TYPE_CHAR_ASTERISK</code></td>
<tr>
<tr>
	<td><code>EXPR_NULL</code></td>
	<td align="center">false</td><td align="center">false</td><td align="center">false</td>
	<td align="center">true</td><td align="center">true</td>
</tr>
<tr>
	<td><code>EXPR_TRUE</code></td>
	<td align="center">true</td><td align="center">false</td><td align="center">true</td>
	<td align="center">false</td><td align="center">false</td>
</tr>
<tr>
	<td><code>EXPR_FALSE</code></td>
	<td align="center">true</td><td align="center">false</td><td align="center">true</td>
	<td align="center">false</td><td align="center">false</td>
</tr>
<tr>
	<td><code>EXPR_CHAR</code></td>
	<td align="center">true</td><td align="center">true</td><td align="center">false</td>
	<td align="center">false</td><td align="center">false</td>
</tr>
<tr>
	<td><code>EXPR_STRING</code></td>
	<td align="center">false</td><td align="center">false</td><td align="center">false</td>
	<td align="center">false</td><td align="center">true</td>
</tr>
<tr>
	<td><code>EXPR_USER_DEFINED</code></td>
	<td align="center">delegate</td><td align="center">delegate</td><td align="center">delegate</td>
	<td align="center">delegate</td><td align="center">delegate</td>
</tr>
<tr>
	<td><code>EXPR_INT</code></td>
	<td align="center">true</td><td align="center">false</td><td align="center">false</td>
	<td align="center">false</td><td align="center">false</td>
</tr>
<tr>
	<td><code>EXPR_PAREN</code></td>
	<td align="center">delegate</td><td align="center">delegate</td><td align="center">delegate</td>
	<td align="center">delegate</td><td align="center">delegate</td>
</tr>
<tr>
	<td><code>EXPR_UNARY</code></td>
	<td align="center">true, if evaluates to int</td><td align="center">false</td>
	<td align="center">true, if evaluates to bool</td>
	<td align="center">false</td><td align="center">false</td>
</tr>
<tr>
	<td><code>EXPR_BINARY</code></td>
	<td align="center">true, if integer operation and operands are int</td>
	<td align="center">false</td><td align="center">true, if boolean operation and operands are bool</td>
	<td align="center">false</td><td align="center">false</td>
</tr>
<tr>
	<td><code>EXPR_CONDITIONAL</code></td>
	<td align="center">true, if operands are int</td>
	<td align="center">true, if operands are char</td>
	<td align="center">true, if operands are bool</td>
	<td align="center">false</td><td align="center">true, if operands are strings</td>
</tr>
</table>

<code>delegate</code> means that the expression has to be evaluated to a new
expression (e.g. resolve the user defined name) and delegate the check to the new expression.

<h3>Cross References</h3>
\anchor fe_crossreference 

To be able to easily access the definition of a type, wherever this type might be used,
it is essential to have direct access to this type. The parser generates the appropriate reference when
checking the names.

<h3>The Data-Representation</h3>
\anchor fe_datarepresentation 

The major reason to implement this IDL compiler has been the optimization of the
marshaling/unmarshaling stubs. Our approach is to analyze the data which will be transmitted by a stub
during compilation time of the IDL compiler. Because the IDL compiler creates the stub it might regard
information it has about the structure of the message call and the target language. To be able to analyze
the data we created a new class structure: the data-representation.

The data-representation is a special view on all elements of the front-end, which could
be transmitted between client and server. To be able to apply operations on that data without affecting the
representation in the front-end this additional structure has been created. This data-representation (DR)
structure is automatically created when the parser scans the IDL and ACF files. The DR is associated with
the FE in order to allow the back-end to access the DR while scanning the FE.

To do the optimization on the DR I introduced a new class <code>CDROptimizer</code>, 
which receives as parameter the FE structure. It scans this structure to find any DR elements and applies
its algorithms to it. Because the optimizer class has access to the FE as well it is able to take attributes
given to elements into account. This optimizer class will not be linked to other elements, so another 
optimization algorithm may easily implemented and/or changed.

During optimization it is possible that the compiler resorts elements of a structure
giving it a totally new layout. If the DR keeps a copy of that structure with each function the compiler
might generate multiple different copies of one structure. To avoid this situation the structure is 
referenced by the functions and is kept with the interface definition. Still each function might alter the
original strcuture, creating a race condition. To allow the modification at all, a structure should be marked
&quot;modified&quot; if a function changed it and can thereafter not be modified. This would lead to an
intolerable result if the last function in the interface is the most used one and should be preffered, 
but the structure has already been changed. An alternative could be to allow one function explicitly to 
change this structure, using an attribute in the IDL or ACF file. This attribute should be associated
with the structure, so it might easily be seen if there is a preffered function and which it is. A structure
should not be changed by the function of a derived interface.

Because only the data-representation has all the information necessary to properly write
the marshaling and unmarshaling code it implements the <code>Write</code> function to support the
back-end. (see <a href="group_backend.html">The Back-End</a> for details). This <code>Write</code> function
has to know about the target language and message call mechanisms.
<b>The data-representation depends on the target language and message call mechanisms!</b>

<h3>The ACF File</h3>
\anchor fe_acffile 

The ACF file is used to apply specialization to the IDL. It's synta is similar to
the syntax of the IDL, but has some additional keywords. The parser is suited to scan both types of files.

As Bryan Ford stated in <i>Separating Presentation from Interface in PRC and IDLs</i> &quot; An 
interface specification is generally independent of the languages used to write its client programs. 
However, presentation specification is fundamentally language-specific, because it defines the interaction
between client and server code and the IPC system ...&quot; Because this language-specific information
is needed by the back-end, but is contained in the ACF file, which is parsed by the front-end, the
parser has stored all language-specific information in the in-memory representation.

<hr>
<p class="footnote">\anchor footnote1 1 - the EBNF or Extended Backus Naur Form is a grammar to describe languages</p>

*/

