/*! \page dice an IDL Compiler for L4

\section SYNOPSIS SYNOPSIS
\b dice [options] <i>&lt;input-file&gt;</i>

\section DESCRIPTION DESCRIPTION
DICE is an IDL compiler, which translates an Interface Definition 
Language (IDL) file into communication stubs for the L4 
micro-kernel. It is mainly used as an tool for the DROPS 
environment. That's where its name is from:
<b>D</b>rops <b>I</b>dl <b>C</b>ompil<b>E</b>r.

Input files should be written in either DCE IDL or CORBA IDL. If 
the IDL file is written using the latter language, the -C option 
should be used. IDL files should have the suffix <b>.idl</b>. The 
compiler uses this suffix to differentiate different kinds of input 
files. Inside an IDL file the <i>include</i> command can be used to 
include other IDL files. To import the type and constant definitions 
from an C header file use the <i>import</i> command inside an DCE 
IDL file.

The DCE IDL and CORBA IDL used by the compiler mostly correspond to 
the public standards, which describe these languages. Some 
additions have been made to the languages to support kernel data 
types of L4. In the CORBA IDL exist the keywords <b>refstring</b> 
to describe a parameter as indirect string and <b>fpage</b> to 
describe a parameter as memory page (flexpage). The DCE IDL has
been extended by some attributes indicating L4 special types and
the <b>fpage</b> type.

The compiler generates several files, also depending on the 
specified options. Using the standard configuration five files are 
generated. The client header and implementation file, the opcode 
file - containing the function codes, the server header file and 
the server-loop file. If the inline code option is specified only 
one client file - the client header file - is generated. If the
server skeleton option is specified a server template file is 
generated, which contains function templates for the functions. If 
the test-suite option is specified the server-template file is 
generated with server functions to test the transmitted values. 
There is also a test-suite file generated, which starts the server 
loop threads and calls the client stubs.

\subsection general General Options
--help, --version, --verbose

\subsection preprocess Preprocessing Options
-E, --preprocess, -I, -D, --with-cpp, -nostdinc, --corba, -M, -MM, -MD, -MD

\subsection backend Code Generation Options
--create-inline, --no-opcodes, --create-skeleton, --template, --server-timeout,
--filename-prefix, --include-prefix, -f, 
--back-end, --client, --server, -O, --testsuite, --message-passing

\section REQUIREMENTS REQUIREMENTS
This compiler uses 'cpp' for preprocessing its input files. Thus 
gcc (at least version 2.95) should be installed.

\section OPTIONS OPTIONS

Most `<b>-W</b>' options have two contrary forms: <b>-W</b>name and
<b>-Wno-</b>name. Only the non-default forms are shown here.

<DL>

\subsection general2 General Options

<DT><b>--help, -h</b></DT>
<DD>Displays the help for dice, which is a short list of its 
options.</DD>

<DT><b>--version, -V</b></DT>
<DD>Display the version of dice and its build date.
This may also display a remark describing the version and
a build number. The build number is <b>not</b> a reliable information.
It is useful if you use dice from a distributed binary package.
It is <b>not</b> useful if you use dice from a source code package.</DD>

<DT><b>--verbose, -v</b> &lt;level&gt;</DT>
<DD>Sets the verbose level of the compiler. The verbose level 
specifies, how much of the debug output the user will see. The 
level may be one of the following numbers:
<BR>1 - lets only the back-end generate output
<BR>2 - lets the back-end and the data-representation generate output
<BR>3 - lets the back-end, the data-representation and the front-end classes
generate output
<BR>4 - lets the factories (name and class factory) generate output
<BR>5 - lets all of the above generate output
<BR>6 - lets all of the above plus the parser generate output
<BR>7 - lets only the parser generate output
</DD>

\subsection preprocess2 Preprocessing Options

<DT><b>-E</b></DT>
<DD>Stops the compiler after preprocessing the input file. The 
output is printed to stdout. 
</DD>

<DT><b>-EXML</b></DT>
<DD>Stops the compiler after parsing the input file. The compiler 
prints the intermediate representation into an XML file. The file 
name is the same as the IDL file's with the idl extension replaced 
with xml.</DD>

<DT><b>--preprocess, -P</b> &lt;string&gt;</DT>
<DD>Hands the <i>string</i> as is to the preprocessor (cpp).</DD>

<DT><b>-Wp,</b>&lt;string&gt;</DT>
<DD>Hands the <i>string</i> as is to the preprocessor --
same as -P<i>string</i>.</DD>

<DT><b>-nostdinc</b></DT>
<DD>Same as -P-nostdinc</DD>

<DT><b>-I</b>&lt;path&gt;</DT>
<DD>Handed to preprocessor (same as -P-I<i>path</i>). <i>path</i>
is also used by dice to find imported files.</DD>

<DT><b>-D</b>&lt;symbol&gt;</DT>
<DD>Handed to preprocessor (same as -P-D<i>symbol</i>).
<i>symbol</i> may also be used with -fuse-symbols to generate
target code which respected defined symbols.</DD>

<DT><b>--with-cpp=</b>&lt;cpp&gt;</DT>
<DD>Defines own preprocessor. The order to determine the used
preprocessor is this:
<br>1. --with-cpp=<i>cpp</i> if '<i>cpp</i> --version' executes
<br>2. environment variable CPP
<br>3. 'cpp' in PATH if 'cpp --version' executes
<br>4. CPP set when configuring dice
<br>5. CPP available when compiling dice
</DD>

<DT><b>--corba, -C</b></DT>
<DD>Regards the input file as CORBA IDL file. If not specified the 
input file is regarded as DCE IDL file.</DD>

<DT><b>-M</b></DT>
<DD>Print the <i>#include</i>d file hierarchy to stdout. Does not compile or
generate intermediate files.</DD>

<DT><b>-MM</b></DT>
<DD>Print the <i>#include</i>d file hierarchy to stdout. Skip standard includes
(the ones included with '<''>'). Does not compile or generate intermediate
files.</DD>

<DT><b>-MD</b></DT>
<DD>Print the <i>#include</i>d file hierarchy to a file with the extension
<i>.d</i> (for IDL file test.idl the file test.d is generated). Dice then
continues with the compilation or generation of intermediate files.</DD>

<DT><b>-MMD</b></DT>
<DD>Same as <b>-MD</b> but does skip standard include files, just like
<b>-MM</b>.</DD>

\subsection backend2 Code Generation Options

<DT><b>--create-inline, -i &lt;mode&gt;</b></DT>
<DD>Creates the client stubs as inline functions. No client 
implementation file is generated. Set &lt;mode&gt; to
<BR><i>static</i> to generate &quot;static inline&quot; or
<BR><i>extern</i> to generate &quot;extern inline&quot;.
<BR>Both options are optional. Without them a simple
&quot;inline&quot; is generated.</DD>

<DT><b>--no-opcode, -n</b></DT>
<DD>Does not generate the opcode header file. The generated code 
does use the constants as would have been specified in the opcode 
file. You could use this option if you already have an opcode
file with different function codes than the compiler would have 
generated.</DD>

<DT><b>--create-skeleton, --template, -t</b></DT>
<DD>Generates a server implementation file, which contains function 
skeletons for the server functions. You could use this option the 
first time you compile an IDL file to generate the function 
skeletons.</DD>

<DT><b>--filename-prefix, -F</b> &lt;string&gt;</DT>
<DD>Prefixes each generated file-name with <i>string</i>.</DD>

<DT><b>--include-prefix, -p</b> &lt;string&gt;</DT>
<DD>Prefixes each filename inside an include statement with 
<i>string</i>.</DD>

<DT><b>-f</b> &lt;string&gt;</DT>
<DD>Supply flags to the compiler. See the following options for details.
</DD>

<DT><b>-ff</b>&lt;string&gt;</DT>
<DD>Sets the granularity which is used to generate target files:
<BR><i>idlfile</i> or 1 to generate one client C file per IDL file 
(default)
<BR><i>module</i> or 2 to generate one client C file per module
<BR><i>interface</i> or 3 to generate one client C file per 
interface
<BR><i>function</i> or 4 to generate one client C file per function
</DD>

<DT><b>-fctypes</b></DT>
<DD>Use C-sytle type names instead of CORBA type names ('long'
instead of 'CORBA_long').
</DD>

<DT><b>-fl4types</b></DT>
<DD>Use L4-style type names instead of CORBA type names
('l4_int32_t' instead of 'CORBA_long'). This option implies
<i>-fctypes</i> for all non-C-style type names.
</DD>

<DT><b>-fopcode-size=</b>&lt;size&gt;</DT>
<DD>Set the size, which is used when transmitting the opcode. Set
<i>size</i> to:
<BR><i>byte</i> or 1 to use a byte
<BR><i>short</i> or 2 to use two bytes
<BR><i>long</i> or 4 to use four bytes
<BR><i>longlong</i> or 8 to use eight bytes
<BR>It is recommended to use the <i>--no-opcode</i> options with
sizes smaller than four bytes, since Dice generated opcodes use
four bytes.
</DD>

<DT><b>-fserver-parameter</b></DT>
<DD>Generates a server loop which expects a void* parameter, which
is cast to the internal CORBA_Environment variable. This way the
user can specify if he wants to provide own values in for the 
CORBA_Environment.
<BR>However, there are cases, where the parameter is mandatory.
For example if the server receives flexpages, the parameter has
to provide an environment whith a proper receive flexpage set.
</DD>

<DT><b>-fno-server-loop</b> or <b>-fno-srvloop</b></DT>
<DD>Does not generate the server loop. Only the dispatch function
is generated.
</DD>

<DT><b>-fno-dispatcher</b></DT>
<DD>Does not generate the dispatcher function. The declaration
in the header file is generated if the server loop function
is generated. The implementation has to be provided by the user.
If the server loop function is also absent, the declaration in
the header file is missing as well (user might define own 
function).
</DD>

<DT><b>-finit-rcvstring</b>[ =&lt;name&gt; ]</DT>
<DD> Makes the server loop use the user specified function to
set the buffers for the received indirect strings. The name of
the function can be specified or is set to <i>dice_init_rcvstring</i>.
<BR>The function has the format:
<BR>void &lt;name&gt;(int, l4_umword_t*, l4_umword_t*, CORBA_Environment*)
<BR>where the int is the number of the currently set string, starting
with zero. The first l4_umword_t should be set to the address of the
buffer, whereas the second contains the buffer's size. The environment
is passed if there are any user-provided information, etc.
</DD>

<DT><b>-fforce-corba-alloc</b></DT>
<DD>Force the use of the 'CORBA_alloc' function. Otherwise the 
'malloc' function pointer in the CORBA_Environment structure
would be used. These functions are only invoked to allocate
memory for variable or fixed sized arrays dynamically.
</DD>

<DT><b>-fforce-env-malloc</b></DT>
<DD>Force the use of CORBA_Environment's malloc member. This is
useful for server's without -fserver-parameter option. Otherwise
CORBA_alloc is used, because it is assumed that the server has
a default CORBA_Environment, which does not contain a valid malloc
function. 
</DD>

<DT><b>-fforce-c-bindings</b></DT>
<DD>For use of L4 C-bindings. Otherwise dice generates the
communication code in inline assemlber directly.
</DD>

<DT><b>-ftrace-server[=&lt;function&gt;]</b></DT>
<DD>Trace all messages received by the server loop. The
print-out contains the opcode, and the thread-ID of the
client. If &lt;function&gt; is given, it is used instead
of <i>printf</i> to print the trace message for the
server. (&lt;function&gt; has to have the same syntax
as <i>printf</i>.)
</DD>

<DT><b>-ftrace-client[=&lt;function&gt;]</b></DT>
<DD>Trace client by printing status messages just before
an IPC and right after. The message before the IPC contains
the ID of the server and the data transferred in the registers.
The message after the IPC contains the result dope and
IPC error code. If &lt;function&gt; is given, it is used
instead of <i>printf</i> to print the trace message for
the server. (&lt;function&gt; has to have the same syntax
as <i>printf</i>.)
</DD>

<DT><b>-ftrace-dump-msgbuf[=&lt;function&gt;]</b></DT>
<DD>Dump the message buffer just before the call IPC,
right after it, and after each wait IPC. If &lt;function&gt;
is given, it is used instead of <i>printf</i> to print the
trace message.
</DD>

<DT><b>-ftrace-dump-msgbuf-dwords=&lt;number&gt;</b></DT>
<DD>Restrict the number of dumped dwords to a maximum of
<i>number</i>. Use this if the message might contain too
many dwords. <i>number</i> can be any positive integer
including zero.
</DD>

<DT><b>-ftrace-function=&lt;function&gt;</b></DT>
<DD>Specifies the function to use instead of <i>printf</i>
to trace output all trace messages (client, server, and
message buffer).
</DD>

<DT><b>-fzero-msgbuf</b></DT>
<DD>Fills the memory region occupied by the message buffer
with zeros for each call and before each wait/reply-and-wait.
This means that the message buffer is 'clean' when data
is put into it.
</DD>

<DT><b>-ftest-no-success-message</b></DT>
<DD>The testsuite will only print error messages. This is
useful if you test large arrays and don't want to see 
success messages scroll by, thus missing the important 
failure messages.
</DD>

<DT><b>-fuse-symbols</b></DT>
<DD>Generated code may include <i>ifdef</i>'s to provide
code for different compile time conditions. These conditions
are usually marked by symbols. If you know the symbols when
using dice and are sure they won't change you can let dice
evaluate them and generate appropriate code.
</DD>

<DT><b>-fno-send-canceled-check</b></DT>
<DD>By default, the client stub will try to resend a
message if the IPC operation was aborted or canceled
by another thread. Using this switch, this behaviour is
turned off.
</DD>

<DT><b>-fconst-as-define</b></DT>
<DD>By default, constants defined in the IDL file using a constant
statement, will be printed as a constant statement in the
generated C header files. Using this switch the constants
are printed as <code>#define</code> statements in the generated
C header files.
</DD>

<DT><b>-fno-l4dir-include-path</b></DT>
<DD>By default '$(L4DIR)/include' is added to the include
paths to be able to include the file 'dice/dice-corba-types.h',
which is parsed by default to "know" the CORBA Types.
If you do not wish to add this path to your include paths,
then use this option. $(L4DIR) is build during 
compile-time of dice and can be set using the <i>--with-l4dir</i>
configure switch.
</DD>

<DT><b>-fkeep-temp-files</b></DT>
<DD>Keeps the temporarely during preprocessing created files.
This option should be used to debug Dice only.
</DD>

<DT><b>--back-end, -B</b> &lt;string&gt;</DT>
<DD>Defines the back-end to use:
<BR><i>string</i> starts with a letter specifying the platform,
kernel interface or language mapping.
<BR><i>p</i> specifies the platform (IA32, IA64, ARM) (default: IA32)
<BR><i>i</i> specifies the kernel interface (v2, x0, x0adapt, v4, 
sock[et], cdr) (default: v2)
<BR><i>m</i> specifies the language mapping (C, CPP) (default: C)
<BR>(For language mapping, only the default values is
currently supported. For kernel interface only v4 is not supported.)
<BR>The kernel interface denotes the ABI used to communicate with
other threads. The 'x0adapt' kernel interface is a support option
to allow V2 applications to run on an X0 kernel. The X0 kernel uses
32Bit thread IDs, wehreas the V2 kernel uses 64Bit thread IDs. X0
can transmit one more double word in a short IPC. The x0adapt interface
maps user-level 64Bit thread IDs to 32Bit X0 thread IDs.
<BR>example: -Bpia32 -Biv2 -BmC
<BR>The ARM back-end is currently only supported for the X0 interface.
</DD>

<DT><b>--client, -c</b></DT>
<DD>Generates client side code only.</DD>

<DT><b>--server, -s</b></DT>
<DD>Generates server side code only.</DD>

<DT><b>-O</b> &lt;level&gt;</DT>
<DD>Sets the optimization level. Currently level 0 and 1 are implemented.
Optimization level 0 does not optimize at all (you should use this for
debugging only). Optimization level 1 currently optimizes marshalling
of arrays and contructed types. If no <i>level</i> is given or -O is not
specified, the highest optimization level is chosen.</DD>

<DT><b>--testsuite, -T</b> &lt;<i>thread</i> | <i>task</i>&gt;</DT>
<DD>Generates a testsuite for the specified IDL file. The compiler 
will overwrite any server skeleton files. It generates additionally 
a test-suite file. You may compile the generated C files and link 
them to an executable, which will run on a bare L4 environment. 
The test application will output any transmission error between 
client and server. You can also specify whether the generated testsuites
run in seperated threads (but the same address space) or in
speperate tasks. If neither is specified <i>thread</i> is chosen.</DD>

<DT><b>--message-passing, -m</b></DT>
<DD>Generates the message passing functions for RPC style functions
as well. E.g. is an unmarshal, receive-any and wait-any function
added for an RPC function at the client's side.</DD>

\subsection warnings Warnings

<DT><b>-Wall</b></DT>
<DD>Ignore all warnings. Or rather combines all of the following options.
</DD>

<DT><b>-Wignore-duplicate-fid</b></DT>
<DD>Duplicate assigned function IDs will not fault in an error, but
initiate a warning.</DD>

<DT><b>-Wprealloc</b></DT>
<DD>Warn if CORBA_alloc is used to allocate memory for unbound
variable sized parameters. CORBA_alloc has to be implemented by
the user, the syntax of this function is the same as malloc, 
which would make a simple implementation simply wrap malloc.</DD>

<DT><b>-Wmaxsize</b></DT>
<DD>Warn if no maximum size is given for a variable sized parameter.
This usually means that the compiler has to guess the size of the
receive buffer and may choose an value wich is either far to large
or far to small. Sometimes the receive buffer is then allocated 
using CORBA_alloc (see -Wprealloc for details on that).</DD>

</DL>

\section AUTHOR AUTHOR
Ronald Aigner <ra3@os.inf.tu-dresden.de>

\section SEE SEE ALSO
cpp(1) for preprocessing options.

http://www.omg.org/ for a specification of the CORBA IDL (or OMG 
IDL). 
or http://www.infosys.tuwien.ac.at/Research/Corba/OMG/corb2prf.htm

http://www.opengroup.org/onlinepubs/9629399/chap4.htm for the DCE IDL
specification.

Project web page: http://os.inf.tu-dresden.de/dice/

*/
